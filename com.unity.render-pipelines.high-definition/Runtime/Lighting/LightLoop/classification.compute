// #pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma multi_compile_local _ LIGHT_CLASSIFICATION
#pragma multi_compile_local _ MATERIAL_CLASSIFICATION

#pragma kernel main

#define FINE_BINNING // Keep in sync with 'deferred.compute' and 'builddispatchindirect.compute'

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/ShaderBase.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/HDStencilUsage.cs.hlsl"

#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

TEXTURE2D_X_UINT2(_StencilTexture);

/* ------------------------------ Outputs ----------------------------------- */

RWStructuredBuffer<uint> g_TileFeatureFlags;

/* ------------------------------ Utilities --------------------------------- */

bool IsBinEmpty(uint tile, uint zBin, uint category, uint eye)
{
    bool b = true;

    const uint tileBufferHeaderIndex = ComputeTileBufferHeaderIndex(tile, category, eye);
    const uint tileRangeData         = TILE_BUFFER[tileBufferHeaderIndex]; // {last << 16 | first}
    const bool isTileEmpty           = tileRangeData == UINT16_MAX;

    if (!isTileEmpty) // Avoid wasted work
    {
        const uint zBinBufferIndex = ComputeZBinBufferIndex(zBin, category, eye);
        const uint zBinRangeData   = _zBinBuffer[zBinBufferIndex]; // {last << 16 | first}

        const uint2 tileEntityIndexRange = uint2(tileRangeData & UINT16_MAX, tileRangeData >> 16);
        const uint2 zBinEntityIndexRange = uint2(zBinRangeData & UINT16_MAX, zBinRangeData >> 16);

        b = !IntervalsOverlap(tileEntityIndexRange, zBinEntityIndexRange);
    }

    return b;
}

/* ------------------------------ Implementation ---------------------------- */

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    groupshared uint gs_TileFeatureFlags;
#endif

[numthreads(TILE_SIZE * TILE_SIZE, 1, 1)]
void main(uint3 threadID : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    const uint  t         = threadID.x;
    const uint2 tileCoord = groupID.xy;
    const uint  eye       = groupID.z;

    const uint  tile              = IndexFromCoordinate(tileCoord, TILE_BUFFER_DIMS.x);
    const uint2 localPixelCoord   = DecodeMorton2D(t & (TILE_SIZE * TILE_SIZE - 1)); // Use AND to inform the compiler
    const uint2 globalPixelCoord  = tileCoord * TILE_SIZE + localPixelCoord;
    const uint2 clampedPixelCoord = min(globalPixelCoord, uint2(_ScreenSize.xy) - 1);

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    if (t == 0) // Avoid bank conflicts
    {
        gs_TileFeatureFlags = 0;
    }
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    uint featureFlags = 0;

    // Unlit object, sky/background and forward opaque tag don't tag the StencilUsage.RequiresDeferredLighting bit
    uint stencilVal = GetStencilValue(LOAD_TEXTURE2D_X(_StencilTexture, clampedPixelCoord));

    // TODO: use coarse stencil here.
    if ((stencilVal & STENCILUSAGE_REQUIRES_DEFERRED_LIGHTING) != 0)
    {
        featureFlags = g_BaseFeatureFlags; // Contain all lightFeatures or 0 (depends if we enable light classification or not)

    #ifdef LIGHT_CLASSIFICATION
        // TODO: optimize using LinearEyeDepth(float2 positionNDC, float deviceDepth, float4 invProjParam).
        float          depth    = LoadCameraDepth(clampedPixelCoord);
        PositionInputs posInput = GetPositionInput(clampedPixelCoord, _ScreenSize.zw, depth, UNITY_MATRIX_I_VP, UNITY_MATRIX_V);
        uint           zBin     = ComputeZBinIndex(posInput.linearDepth);

        if (!IsBinEmpty(tile, zBin, BOUNDEDENTITYCATEGORY_PUNCTUAL_LIGHT, eye))
        {
            featureFlags |= LIGHTFEATUREFLAGS_PUNCTUAL;
        }

        if (!IsBinEmpty(tile, zBin, BOUNDEDENTITYCATEGORY_AREA_LIGHT, eye))
        {
            featureFlags |= LIGHTFEATUREFLAGS_AREA;
        }

        if (!IsBinEmpty(tile, zBin, BOUNDEDENTITYCATEGORY_REFLECTION_PROBE, eye))
        {
            featureFlags |= LIGHTFEATUREFLAGS_ENV;
        }
    #endif // LIGHT_CLASSIFICATION

    #ifdef MATERIAL_CLASSIFICATION
        featureFlags |= MATERIAL_FEATURE_FLAGS_FROM_GBUFFER(clampedPixelCoord);
    #endif // MATERIAL_CLASSIFICATION
    }

#if (defined(PLATFORM_SUPPORTS_WAVE_INTRINSICS) && (PLATFORM_LANE_COUNT >= (TILE_SIZE * TILE_SIZE)))
    featureFlags = WaveActiveBitOr(featureFlags);
#else
    InterlockedOr(gs_TileFeatureFlags, featureFlags);

    GroupMemoryBarrierWithGroupSync(); // Wait for writes to gs_TileFeatureFlags

    featureFlags = gs_TileFeatureFlags;
#endif

    if (t == 0) // Avoid bank conflicts
    {
        uint bufferIndex = tile + IndexFromCoordinate(uint3(0, 0, eye), TILE_BUFFER_DIMS);
        g_TileFeatureFlags[bufferIndex] = featureFlags;
    }
}
