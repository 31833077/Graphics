#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

#pragma kernel main

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#define NO_SHADERVARIABLESGLOBAL_HLSL
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"
#undef  NO_SHADERVARIABLESGLOBAL_HLSL
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/ClippingUtilities.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
StructuredBuffer<FiniteLightBound> _EntityBoundsBuffer : register(t0);

/* ------------------------------ Outputs ----------------------------------- */

// 1x list for all entites (sorted by category, we concatenate lists of all views).
RWStructuredBuffer<float4> _xyBoundsBuffer : register(u0); // {x_min, x_max, y_min, y_max}
RWStructuredBuffer<float2>  _wBoundsBuffer : register(u1); // {w_min, w_max}

/* ------------------------------ Utilities --------------------------------- */

/* ------------------------------ Implementation ---------------------------- */

// !!! IMPORTANT !!!
// The legacy code from Morten provides us special projection matrices (and their inverses).
// These matrices are different from the matrices the HDRP uses.
// There is no reversed-Z buffering (effectively, forced UNITY_REVERSED_Z = 0).
// Additionally, there is no clip-space flip (effectively, forced UNITY_UV_STARTS_AT_TOP = 0).
// Therefore, all coordinate systems are left-handed, Y-up, without W-flip.
// Near and far planes are swapped in the case of Z-reversal, but it does not change the algorithm.
// y  z
// | /
// 0 -- x

#ifdef SHADER_API_XBOXONE
// The Xbox shader compiler expects the lane swizzle mask to be a compile-time constant.
// In our case, the mask is a compile-time constant, but it is defined inside a loop
// that is unrolled at the compile time, and the constants are generated during the
// constant propagation pass of the optimizer. This works fine on PlayStation, but does not work
// on Xbox. In order to avoid writing hideous code specifically for Xbox, we disable the support
// of wave intrinsics on Xbox until the Xbox compiler is fixed.
#undef PLATFORM_SUPPORTS_WAVE_INTRINSICS
#endif

// Clipping a plane by a cube may produce a hexagon (6-gon).
// Clipping a hexagon by 4 planes (substitute a quad for the plane) may produce a decagon (10-gon).
#define MAX_CLIP_VERTS     (10)
#define NUM_VERTS          (8)
#define NUM_FACES          (6)
#define NUM_PLANES         (6)
#define THREADS_PER_GROUP  (64)
#define THREADS_PER_ENTITY (4) // Set to 1 for debugging
#define ENTITIES_PER_GROUP (THREADS_PER_GROUP / THREADS_PER_ENTITY)
#define VERTS_PER_GROUP    (NUM_VERTS * ENTITIES_PER_GROUP)
#define VERTS_PER_THREAD   (NUM_VERTS / THREADS_PER_ENTITY)
#define FACES_PER_THREAD   (DIV_ROUND_UP(NUM_FACES, THREADS_PER_ENTITY))
#define VERTS_PER_FACE     (4)

// All planes and faces are always in the standard order (see below).
// Near and far planes are swapped in the case of Z-reversal, but it does not change the algorithm.
#define FACE_LEFT   (1 << 0) // -X
#define FACE_RIGHT  (1 << 1) // +X
#define FACE_BOTTOM (1 << 2) // -Y
#define FACE_TOP    (1 << 3) // +Y
#define FACE_FRONT  (1 << 4) // -Z
#define FACE_BACK   (1 << 5) // +Z
#define FACE_MASK   ((1 << NUM_FACES) - 1)

// A list of vertices for each face (CCW order w.r.t. its normal, starting from the LSB).
#define VERT_LIST_LEFT   ((4) << 9 | (6) << 6 | (2) << 3 | (0) << 0)
#define VERT_LIST_RIGHT  ((3) << 9 | (7) << 6 | (5) << 3 | (1) << 0)
#define VERT_LIST_BOTTOM ((1) << 9 | (5) << 6 | (4) << 3 | (0) << 0)
#define VERT_LIST_TOP    ((6) << 9 | (7) << 6 | (3) << 3 | (2) << 0)
#define VERT_LIST_FRONT  ((2) << 9 | (3) << 6 | (1) << 3 | (0) << 0)
#define VERT_LIST_BACK   ((5) << 9 | (7) << 6 | (6) << 3 | (4) << 0)

// All vertices are always in the standard order (see below).
uint GetFaceMaskOfVertex(uint v)
{
    // 0: (-1, -1, -1) -> { FACE_LEFT  | FACE_BOTTOM | FACE_FRONT }
    // 1: (+1, -1, -1) -> { FACE_RIGHT | FACE_BOTTOM | FACE_FRONT }
    // 2: (-1, +1, -1) -> { FACE_LEFT  | FACE_TOP    | FACE_FRONT }
    // 3: (+1, +1, -1) -> { FACE_RIGHT | FACE_TOP    | FACE_FRONT }
    // 4: (-1, -1, +1) -> { FACE_LEFT  | FACE_BOTTOM | FACE_BACK  }
    // 5: (+1, -1, +1) -> { FACE_RIGHT | FACE_BOTTOM | FACE_BACK  }
    // 6: (-1, +1, +1) -> { FACE_LEFT  | FACE_TOP    | FACE_BACK  }
    // 7: (+1, +1, +1) -> { FACE_RIGHT | FACE_TOP    | FACE_BACK  }
    // ((v & 1) == 0) ? 1 : 2) | ((v & 2) == 0) ? 4 : 8) | ((v & 4) == 0) ? 16 : 32)
    uint f = (FACE_LEFT   << BitFieldExtract(v, 0, 1))
           | (FACE_BOTTOM << BitFieldExtract(v, 1, 1))
           | (FACE_FRONT  << BitFieldExtract(v, 2, 1));

    return f;
};

float3 GenerateVertexOfStandardCube(uint v)
{
    float3 p;

    p.x = ((v & 1) == 0) ? -1 : 1; // FACE_LEFT   : FACE_RIGHT
    p.y = ((v & 2) == 0) ? -1 : 1; // FACE_BOTTOM : FACE_TOP
    p.z = ((v & 4) == 0) ? -1 : 1; // FACE_FRONT  : FACE_BACK

    return p;
}

uint GetVertexListOfFace(uint f)
{
    // Warning: don't add 'static' here unless you want really bad code gen.
    const uint3 allVertLists = uint3((VERT_LIST_RIGHT << 12) | VERT_LIST_LEFT,
                                     (VERT_LIST_TOP   << 12) | VERT_LIST_BOTTOM,
                                     (VERT_LIST_BACK  << 12) | VERT_LIST_FRONT);

    return BitFieldExtract(allVertLists[f >> 1], 12 * (f & 1), 12);
}

// 5 arrays * 128 elements * 4 bytes each = 2560 bytes.
groupshared float gs_HapVertsX[VERTS_PER_GROUP];
groupshared float gs_HapVertsY[VERTS_PER_GROUP];
groupshared float gs_HapVertsZ[VERTS_PER_GROUP];
groupshared float gs_HapVertsW[VERTS_PER_GROUP];
groupshared uint  gs_BehindMasksOfVerts[VERTS_PER_GROUP]; // 6 planes each (HLSL does not support small data types)

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
// 1 array * 16 elements * 4 bytes each = 64 bytes.
groupshared uint  gs_CullClipFaceMasks[ENTITIES_PER_GROUP]; // 6 faces each (HLSL does not support small data types)

// 8 arrays * 16 elements * 4 bytes each = 512 bytes.
// These are actually floats reinterpreted as uints.
// The reason is because floating-point atomic operations are not supported.
groupshared uint  gs_NdcAaBbMinPtX[ENTITIES_PER_GROUP];
groupshared uint  gs_NdcAaBbMaxPtX[ENTITIES_PER_GROUP];
groupshared uint  gs_NdcAaBbMinPtY[ENTITIES_PER_GROUP];
groupshared uint  gs_NdcAaBbMaxPtY[ENTITIES_PER_GROUP];
// Skip Z, we do not need it.
groupshared uint  gs_NdcAaBbMinPtW[ENTITIES_PER_GROUP]; // View-space Z coordinate
groupshared uint  gs_NdcAaBbMaxPtW[ENTITIES_PER_GROUP]; // View-space Z coordinate
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

// Returns 'true' if it manages to cull the face.
bool TryCullFace(uint f, uint behindMasksOfVerts[NUM_VERTS])
{
    uint cullMaskOfFace = FACE_MASK; // Initially behind
    uint vertListOfFace = GetVertexListOfFace(f);

    for (uint j = 0; j < VERTS_PER_FACE; j++)
    {
        uint v = BitFieldExtract(vertListOfFace, 3 * j, 3);
        // Non-zero if ALL the vertices are behind any of the planes.
        cullMaskOfFace &= behindMasksOfVerts[v];
    }

    return (cullMaskOfFace != 0);
}

void ClipFaceAgainstViewVolume(uint f, uint behindMasksOfVerts[NUM_VERTS], uint baseVertexOffset,
                               out uint srcBegin, out uint srcSize,
                               out float4 vertRingBuffer[MAX_CLIP_VERTS])
{
    srcBegin = 0;
    srcSize  = VERTS_PER_FACE;

    uint clipMaskOfFace = 0; // Initially in front
    uint vertListOfFace = GetVertexListOfFace(f);

    for (uint j = 0; j < VERTS_PER_FACE; j++)
    {
        uint v = BitFieldExtract(vertListOfFace, 3 * j, 3);
        // Non-zero if ANY of the vertices are behind any of the planes.
        clipMaskOfFace |= behindMasksOfVerts[v];

        // Not all edges may require clipping. However, filtering the vertex list
        // is somewhat expensive, so we currently don't do it.
        vertRingBuffer[j].x = gs_HapVertsX[baseVertexOffset + v];
        vertRingBuffer[j].y = gs_HapVertsY[baseVertexOffset + v];
        vertRingBuffer[j].z = gs_HapVertsZ[baseVertexOffset + v];
        vertRingBuffer[j].w = gs_HapVertsW[baseVertexOffset + v];
    }

    // Sutherland-Hodgeman polygon clipping algorithm.
    // It works by clipping the entire polygon against one clipping plane at a time.
    while (clipMaskOfFace != 0)
    {
        uint p = firstbitlow(clipMaskOfFace);

        uint dstBegin, dstSize;
        ClipPolygonAgainstPlane(p, srcBegin, srcSize, vertRingBuffer, dstBegin, dstSize);

        srcBegin = dstBegin;
        srcSize  = dstSize;

        clipMaskOfFace ^= 1 << p; // Clear the bit to continue using firstbitlow()
    }
}

void UpdateAaBb(uint srcBegin, uint srcSize, float4 vertRingBuffer[MAX_CLIP_VERTS],
                bool isOrthoProj, float4x4 invProjMat,
                inout float4 ndcAaBbMinPt, inout float4 ndcAaBbMaxPt)
{
#ifdef OBTUSE_COMPILER
    uint modSrcIdx = srcBegin % MAX_CLIP_VERTS;
#endif
    for (uint j = srcBegin; j < (srcBegin + srcSize); j++)
    {
    #ifndef OBTUSE_COMPILER
        uint modSrcIdx = j % MAX_CLIP_VERTS;
    #endif
        float4 hapVert = vertRingBuffer[modSrcIdx];
        // Clamp to the bounds in case of numerical errors (may still generate -0).
        float3 rapVertNDC = saturate(hapVert.xyz * rcp(hapVert.w));
        float  rbpVertVSz = hapVert.w;

        if (isOrthoProj) // Must replace (w = 1)
        {
            rbpVertVSz = dot(invProjMat[2], hapVert);
        }

        ndcAaBbMinPt = min(ndcAaBbMinPt, float4(rapVertNDC, rbpVertVSz));
        ndcAaBbMaxPt = max(ndcAaBbMaxPt, float4(rapVertNDC, rbpVertVSz));
    #ifdef OBTUSE_COMPILER
        modSrcIdx++;
        modSrcIdx = (modSrcIdx == MAX_CLIP_VERTS) ? 0 : modSrcIdx;
    #endif
    }
}

// Given: 'C' is the center of the sphere in the view space, 'r' is its radius;
// 'projScale' and 'projOffset' are used to perform projection of the X (or Y) component of a vector.
float2 ComputeBoundsOfProjectedSphere(float3 C, float r, float projScale, float projOffset)
{
    float xMin, xMax;

    // See sec. 8.2.1 of https://foundationsofgameenginedev.com/#fged2 for an alternative derivation.
    // Goal: find the planes that pass through the origin O, bound the sphere, and form
    // an axis-aligned rectangle at the intersection with the projection plane.
    // Solution (for the X-coordinate):
    // The intersection of the bounding planes and the projection plane must be vertical lines,
    // which means that the bounding planes must be tangent to the Y-axis.
    // The bounding planes must be also tangent to the sphere.
    // Call the intersection points of the two vertical bounding planes and the bounding
    // sphere B and D. Assume that B is on the left of C; D is on the right of C.
    // Note that C may be behind the origin, so the same generally goes for B and D.
    // BC is normal w.r.t. the bounding plane, so it is normal w.r.t. the Y-axis; |BC| = r.
    // As a consequence, it lies in a plane parallel to the the O-X-Z plane.
    // Consider B'C', which is an orthogonal projection of BC onto the actual O-X-Z plane.
    // (Imagine sliding the sphere up or down between the bounding planes).
    // We then consider a triangle OB'C' that lies entirely in the O-X-Z plane.
    // The coordinates are: OB' = (b.x, 0, b.z), OC' = (c.x, 0, c.z).
    float3 B, D;
    // OBC is a right triangle. So is OB'C'.
    // |BC| = |B'C'| = r.
    // |OB'|^2 = |OC'|^2 - |B'C'|^2.
    float lenSqOC = dot(C.xz, C.xz);
    float lenSqOB = lenSqOC - r * r;
    // If |OB'| = 0 or |OC'| = 0, the bounding planes tangent to the sphere do not exist.
    if (lenSqOB > 0)
    {
        float lenOB = sqrt(lenSqOB);
        // |OB' x OC'| = |OB'| * |OC'| * Sin[a'].
        //  OB' . OC'  = |OB'| * |OC'| * Cos[a'].
        // We can determine Sin[a'] = |B'C'| / |OC'| = R / |OC'|.
        // Cos[a'] = Sqrt[1 - Sin[a']^2].
        // (OB' x OC') points along Y.
        // (OB' x OC').y = b.z * c.x - b.x * c.z.
        // Therefore,  b.z * c.x - b.x * c.z = |OB'| * |OC'| * Sin[a'].
        // OB' . OC' = b.x * c.x + b.z * c.z = |OB'| * |OC'| * Cos[a'].
        // Since we don't care about the scale, and |OB'| != 0 and |OC'| != 0,
        // we can equivalently solve
        // z * c.x - x * c.z = |OC'|^3 * Sin[a'].
        // x * c.x + z * c.z = |OC'|^3 * Cos[a'].
        // With 2 equations and 2 unknowns, we can easily solve this linear system.
        // The solutions is
        // x = -c.z * r + c.x * |OB'|.
        // z =  c.x * r + c.z * |OB'|.
        B.x = C.x * lenOB - (C.z * r);
        B.z = C.z * lenOB + (C.x * r);
        // (OD' x OC') points along Y.
        // (OD' x OC').y = d.z * c.x - d.x * c.z.
        // We must solve
        // z * c.x - x * c.z = -|OC'|^3 * Sin[a'].
        // x * c.x + z * c.z =  |OC'|^3 * Cos[a'].
        // The solution is
        // x =  c.z * r + c.x * |OB'|.
        // z = -c.x * r + c.z * |OB'|.
        D.x = C.x * lenOB + (C.z * r);
        D.z = C.z * lenOB - (C.x * r);
        // We can transform OB and OD as direction vectors.
        // For the simplification below, see OptimizeProjectionMatrix.
        float rapBx = (B.x * rcp(B.z)) * projScale + projOffset;
        float rapDx = (D.x * rcp(D.z)) * projScale + projOffset;
        // One problem with the above is that this direction may, for certain spheres,
        // point behind the origin (B.z <= 0 or D.z <= 0).
        // At this point we know that the sphere at least *partially* in front of the origin,
        // and that it is we are not inside the sphere, so there is at least one valid
        // plane (and one valid direction). We just need the second direction to go "in front"
        // of the first one to extend the bounding box.
        xMin = (B.z > 0) ? rapBx : -FLT_INF;
        xMax = (D.z > 0) ? rapDx :  FLT_INF;
    }
    else
    {
        // Conservative estimate (we do not cull the bounding sphere using the view frustum).
        xMin = -1;
        xMax =  1;
    }

    return float2(xMin, xMax);
}

// *************************************************************************************************
// The goal of this program is to compute the AABB of a bounded entity in the NDC space ([0, 1] range).
// The entity is represented by a bounding sphere and a right bounding frustum with 6 faces and 8 vertices.
// The resulting bounding volume is defined by the the intersection of the sphere and the frustum.
//
// Since an entity's bounding volume may be partially off-screen, we must clip it before computing the AABB.
// Clipping the resulting AABB (rather than the bounding volume itself) may result in a loose AABB.
//
// To avoid having to deal with the "Moebius twist" property of the perspective transform,
// we perform clipping using the homogeneous (projective) post-perspective coordinates.
// This clipping method in described in Blinn's paper titled "Line Clipping".
//
// The algorithm processes an entity on 4 threads. While all 6 faces may require clipping in the
// worst case, clipping more than 4 faces is very uncommon (typically, we clip 0, 3 or 4).
// Some faces may require culling rather than clipping (the former is simpler).
//
// It's important to realize that face culling may end up culling 5 (or even all 6) faces.
// This means that the clipped volume may be reduced to a single polygon, or nothing at all.
// (Imagine a view volume completely or partially inside a bounding volume).
// Therefore, we must perform view-volume-corner-inside-bounding-volume tests.
//
// Notation:
// rbp - real (3D) coordinates before perspective
// hbp - hom. (4D) coordinates before perspective
// hap - hom. (4D) coordinates after  perspective
// rap - real (3D) coordinates after  perspective (after division by w)
// *************************************************************************************************

[numthreads(THREADS_PER_ENTITY, ENTITIES_PER_GROUP, 1)]
void main(uint3 threadID : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    const uint t      = threadID.x;
    const uint entity = threadID.y;
    const uint g      = groupID.x;
    const uint eye    = groupID.z;

    const uint baseVertexOffset   = entity * NUM_VERTS;
    const uint globalEntityIndex  = IndexFromCoordinate(uint2(entity, g), ENTITIES_PER_GROUP);
    const uint clampedEntityIndex = min(globalEntityIndex, _BoundedEntityCount - 1);

    // Helper threads may perform the same computation on valid data,
    // but do not store the results of the computation to memory.
    const bool isHelperThread = globalEntityIndex != clampedEntityIndex;

    const uint             bufferIndex = ComputeEntityBoundsBufferIndex(clampedEntityIndex, eye);
    const FiniteLightBound cullData    = _EntityBoundsBuffer[bufferIndex];

    const float4x4 projMat    = g_mProjectionArr[eye];
    const float4x4 invProjMat = g_mInvProjectionArr[eye];

    // Bounding frustum.
    const float3 rbpC  = cullData.center.xyz;   // View-space
    const float3 rbpX  = cullData.boxAxisX.xyz; // Pre-scaled
    const float3 rbpY  = cullData.boxAxisY.xyz; // Pre-scaled
    const float3 rbpZ  = cullData.boxAxisZ.xyz; // Pre-scaled
    const float scale  = cullData.scaleXY;      // scale.x = scale.y
    // Bounding sphere.
    const float radius = cullData.radius;

#ifndef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    // (0) Initialize the TGSM.
    if (t == 0) // Avoid bank conflicts
    {
        gs_CullClipFaceMasks[entity] = 0; // Initially inside
        gs_NdcAaBbMinPtX[entity]     = asuint(1.0f);
        gs_NdcAaBbMaxPtX[entity]     = asuint(0.0f);
        gs_NdcAaBbMinPtY[entity]     = asuint(1.0f);
        gs_NdcAaBbMaxPtY[entity]     = asuint(0.0f);
        // Skip Z, we do not need it.
        gs_NdcAaBbMinPtW[entity]     = asuint(FLT_INF);
        gs_NdcAaBbMaxPtW[entity]     = asuint(0.0f);
    }
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    float4 ndcAaBbMinPt = float4(1, 1, 1, FLT_INF);
    float4 ndcAaBbMaxPt = 0;

    // We must determine whether we have to clip or cull any of the faces.
    // If all vertices of a face are inside with respect to all the culling planes,
    // we can trivially accept that face. If all vertices of a face are behind
    // any single plane, we can trivially reject (cull) that face.
    uint cullClipFaceMask = 0; // Initially inside

    uint i; // Avoid multiply-declared variable warning

    // (1) Compute the vertices of the bounding frustum.
    for (i = 0; i < VERTS_PER_THREAD; i++)
    {
        uint v = t + i * THREADS_PER_ENTITY;

        // rbpVerts[0] = rbpC - rbpX * scale - rbpY * scale - rbpZ; (-s, -s, -1)
        // rbpVerts[1] = rbpC + rbpX * scale - rbpY * scale - rbpZ; (+s, -s, -1)
        // rbpVerts[2] = rbpC - rbpX * scale + rbpY * scale - rbpZ; (-s, +s, -1)
        // rbpVerts[3] = rbpC + rbpX * scale + rbpY * scale - rbpZ; (+s, +s, -1)
        // rbpVerts[4] = rbpC - rbpX         - rbpY         + rbpZ; (-1, -1, +1)
        // rbpVerts[5] = rbpC + rbpX         - rbpY         + rbpZ; (+1, -1, +1)
        // rbpVerts[6] = rbpC - rbpX         + rbpY         + rbpZ; (-1, +1, +1)
        // rbpVerts[7] = rbpC + rbpX         + rbpY         + rbpZ; (+1, +1, +1)

        float3 m = GenerateVertexOfStandardCube(v);
        m.xy *= ((v & 4) == 0) ? scale : 1; // X, Y in [-scale, scale]

        float3 rbpVertVS = rbpC + m.x * rbpX + m.y * rbpY + m.z * rbpZ;
        // Avoid generating (w = 0).
        rbpVertVS.z = (abs(rbpVertVS.z) > FLT_MIN) ? rbpVertVS.z : FLT_MIN;

        float4 hapVert = mul(projMat, float4(rbpVertVS, 1));

        // Warning: the W component may be negative.
        // Flipping the -W pyramid by negating all coordinates is incorrect
        // and will break both classification and clipping.
        // For the orthographic projection, (w = 1).

        // Transform the X and Y components: [-w, w] -> [0, w].
        hapVert.xy = 0.5 * hapVert.xy + (0.5 * hapVert.w);

        // For each vertex, we must determine whether it is within the bounds.
        // For culling and clipping, we must know, per culling plane, whether the vertex
        // is in the positive or the negative half-space.
        uint behindMask = 0; // Initially in front

        // Consider the vertex to be inside the view volume if:
        // 0 <= x <= w
        // 0 <= y <= w   <-- include boundary points to avoid clipping them later
        // 0 <= z <= w
        // w is always valid
        // TODO: add epsilon for numerical robustness?

        for (uint j = 0; j < (NUM_PLANES / 2); j++)
        {
            float w = hapVert.w;

            behindMask |= (hapVert[j] < 0 ? 1 : 0) << (2 * j + 0); // Planes crossing '0'
            behindMask |= (hapVert[j] > w ? 1 : 0) << (2 * j + 1); // Planes crossing 'w'
        }

        if (behindMask == 0) // Inside?
        {
            // Clamp to the bounds in case of numerical errors (may still generate -0).
            float3 rapVertNDC = saturate(hapVert.xyz * rcp(hapVert.w));

            ndcAaBbMinPt = min(ndcAaBbMinPt, float4(rapVertNDC, rbpVertVS.z));
            ndcAaBbMaxPt = max(ndcAaBbMaxPt, float4(rapVertNDC, rbpVertVS.z));
        }
        else // Outside
        {
            // Mark all the faces of the bounding frustum associated with this vertex.
            cullClipFaceMask |= GetFaceMaskOfVertex(v);
        }

        gs_HapVertsX[baseVertexOffset + v]          = hapVert.x;
        gs_HapVertsY[baseVertexOffset + v]          = hapVert.y;
        gs_HapVertsZ[baseVertexOffset + v]          = hapVert.z;
        gs_HapVertsW[baseVertexOffset + v]          = hapVert.w;
        gs_BehindMasksOfVerts[baseVertexOffset + v] = behindMask;
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        cullClipFaceMask |= LaneSwizzle(cullClipFaceMask, andMask, orMask, xorMask);
    }
#else
    InterlockedOr(gs_CullClipFaceMasks[entity], cullClipFaceMask);

    GroupMemoryBarrierWithGroupSync();

    cullClipFaceMask = gs_CullClipFaceMasks[entity];
#endif

    // (2) Test the corners of the view volume.
    if (cullClipFaceMask != 0)
    {
        // The entity is partially outside the view volume.
        // Therefore, some of the corners of the view volume may be inside the entity's bounding frustum.
        // We perform aggressive culling, so we must make sure they are accounted for.
        // We can exploit the properties of the frustum by building an entity-space projection matrix.
        // P_v = T * (R * S) * P_l
        // P_l = (R * S)^{-1} * T^{-1} * P_v
        float4x4 invTranslateToEntitySpace      = Translation4x4(-rbpC);
        float4x4 invRotateAndScaleInEntitySpace = Homogenize3x3(Invert3x3(ScaledRotation3x3(rbpX, rbpY, rbpZ)));
        // TODO: avoid full inversion by using unit vectors and passing magnitudes explicitly.

        // This (orthographic) projection matrix maps a view-space point to a entity-space [-1, 1]^3 cube.
        float4x4 entitySpaceMatrix = mul(invRotateAndScaleInEntitySpace, invTranslateToEntitySpace);

        if (scale != 1) // Perspective entity space?
        {
            // Compute the parameters of the perspective projection.
            float s = scale;
            float e = -1 - 2 * (s * rcp(1 - s)); // Signed distance from the origin to the eye
            float n = -e - 1;                    // Distance from the eye to the near plane
            float f = -e + 1;                    // Distance from the eye to the far plane
            float g = f;                         // Distance from the eye to the projection plane

            float4x4 invTranslateEye = Translation4x4(float3(0, 0, -e));
            float4x4 perspProjMatrix = PerspectiveProjection4x4(1, g, n, f);

            entitySpaceMatrix = mul(mul(perspProjMatrix, invTranslateEye), entitySpaceMatrix);
        }

        for (i = 0; i < VERTS_PER_THREAD; i++)
        {
            uint v = t + i * THREADS_PER_ENTITY;

            float3 rapVertCS = GenerateVertexOfStandardCube(v);
            rapVertCS.z = rapVertCS.z * 0.5 + 0.5; // View's projection matrix MUST map Z to [0, 1]

            float4 hbpVertVS = mul(invProjMat, float4(rapVertCS, 1)); // Clip to view space
            float4 hapVertLS = mul(entitySpaceMatrix, hbpVertVS);     // View to entity space

            // Consider the vertex to be inside the entity's bounding frustum if:
            // -w < x < w
            // -w < y < w   <-- exclude boundary points, as we will not clip using these vertices
            // -w < z < w   <-- assume that Z-precision is not very important here
            // 0  < w
            // TODO: add epsilon for numerical robustness?

            bool inside = Max3(abs(hapVertLS.x), abs(hapVertLS.y), abs(hapVertLS.z)) < hapVertLS.w;

            if (inside)
            {
                float3 rapVertNDC = float3(rapVertCS.xy * 0.5 + 0.5, rapVertCS.z);
                float  rbpVertVSz = hbpVertVS.z * rcp(hbpVertVS.w);

                ndcAaBbMinPt = min(ndcAaBbMinPt, float4(rapVertNDC, rbpVertVSz));
                ndcAaBbMaxPt = max(ndcAaBbMaxPt, float4(rapVertNDC, rbpVertVSz));
            }
        }
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    GroupMemoryBarrierWithGroupSync();
#endif

    uint behindMasksOfVerts[NUM_VERTS];

    for (i = 0; i < NUM_VERTS; i++)
    {
        behindMasksOfVerts[i] = gs_BehindMasksOfVerts[baseVertexOffset + i];
    }

    // (3) Cull the faces.
    {
        const uint cullFaceMask   = cullClipFaceMask;
        const uint numFacesToCull = countbits(cullFaceMask); // [0, 6]

        for (i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = t + i * THREADS_PER_ENTITY;

            if (n < numFacesToCull)
            {
                uint f = NthBitLow(cullFaceMask, n);

                if (TryCullFace(f, behindMasksOfVerts))
                {
                    cullClipFaceMask ^= 1 << f; // Clear the bit
                }
            }
        }
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        cullClipFaceMask &= LaneSwizzle(cullClipFaceMask, andMask, orMask, xorMask);
    }
#else
    InterlockedAnd(gs_CullClipFaceMasks[entity], cullClipFaceMask);

    GroupMemoryBarrierWithGroupSync();

    cullClipFaceMask = gs_CullClipFaceMasks[entity];
#endif

    // (4) Clip the faces.
    {
        const uint clipFaceMask   = cullClipFaceMask;
        const uint numFacesToClip = countbits(clipFaceMask); // [0, 6]

        for (i = 0; i < FACES_PER_THREAD; i++)
        {
            uint n = t + i * THREADS_PER_ENTITY;

            if (n < numFacesToClip)
            {
                uint f = NthBitLow(clipFaceMask, n);

                uint   srcBegin, srcSize;
                float4 vertRingBuffer[MAX_CLIP_VERTS];
                ClipFaceAgainstViewVolume(f, behindMasksOfVerts, baseVertexOffset,
                                          srcBegin, srcSize, vertRingBuffer);
                UpdateAaBb(srcBegin, srcSize, vertRingBuffer, g_isOrthographic != 0, invProjMat,
                           ndcAaBbMinPt, ndcAaBbMaxPt);
            }
        }
    }

#ifdef PLATFORM_SUPPORTS_WAVE_INTRINSICS
    for (i = 0; i < FastLog2(THREADS_PER_ENTITY); i++)
    {
        uint andMask = PLATFORM_LANE_COUNT - 1; // All lanes
        uint orMask  = 0;                       // Plays no role
        uint xorMask = 1 << i;                  // Flip bits one by one starting from the LSB

        ndcAaBbMinPt.x = min(ndcAaBbMinPt.x, LaneSwizzle(ndcAaBbMinPt.x, andMask, orMask, xorMask));
        ndcAaBbMaxPt.x = max(ndcAaBbMaxPt.x, LaneSwizzle(ndcAaBbMaxPt.x, andMask, orMask, xorMask));
        ndcAaBbMinPt.y = min(ndcAaBbMinPt.y, LaneSwizzle(ndcAaBbMinPt.y, andMask, orMask, xorMask));
        ndcAaBbMaxPt.y = max(ndcAaBbMaxPt.y, LaneSwizzle(ndcAaBbMaxPt.y, andMask, orMask, xorMask));
        // Skip Z, we do not need it.
        ndcAaBbMinPt.w = min(ndcAaBbMinPt.w, LaneSwizzle(ndcAaBbMinPt.w, andMask, orMask, xorMask));
        ndcAaBbMaxPt.w = max(ndcAaBbMaxPt.w, LaneSwizzle(ndcAaBbMaxPt.w, andMask, orMask, xorMask));
    }
#else
    // Integer comparison works for floating-point numbers as long as the sign bit is 0.
    // We must take care of -0 ourselves. saturate() does not help.
    InterlockedMin(gs_NdcAaBbMinPtX[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.x)));
    InterlockedMax(gs_NdcAaBbMaxPtX[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.x)));
    InterlockedMin(gs_NdcAaBbMinPtY[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.y)));
    InterlockedMax(gs_NdcAaBbMaxPtY[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.y)));
    // Skip Z, we do not need it.
    InterlockedMin(gs_NdcAaBbMinPtW[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMinPt.w)));
    InterlockedMax(gs_NdcAaBbMaxPtW[entity], asuint(CLEAR_SIGN_BIT(ndcAaBbMaxPt.w)));

    GroupMemoryBarrierWithGroupSync();

    ndcAaBbMinPt.x = asfloat(gs_NdcAaBbMinPtX[entity]);
    ndcAaBbMaxPt.x = asfloat(gs_NdcAaBbMaxPtX[entity]);
    ndcAaBbMinPt.y = asfloat(gs_NdcAaBbMinPtY[entity]);
    ndcAaBbMaxPt.y = asfloat(gs_NdcAaBbMaxPtY[entity]);
    // Skip Z, we do not need it.
    ndcAaBbMinPt.w = asfloat(gs_NdcAaBbMinPtW[entity]);
    ndcAaBbMaxPt.w = asfloat(gs_NdcAaBbMaxPtW[entity]);
#endif // PLATFORM_SUPPORTS_WAVE_INTRINSICS

    // (5) Compute the AABB of the bounding sphere.
    if (radius > 0)
    {
        // Occasionally, an intersection of AABBs of a bounding sphere and a bounding frustum
        // results in a tighter AABB when compared to using the AABB of the frustum alone.
        // That is the case (mostly) for sphere-capped spot lights with very wide angles.
        // Note that, unfortunately, it is not quite as tight as an AABB of a CSG intersection
        // of a sphere and frustum. Also note that the algorithm below doesn't clip the bounding
        // sphere against the view frustum before computing the bounding box, simply because it is
        // too hard/expensive. I will leave it as a TODO in case someone wants to tackle this problem.
        if ((rbpC.z + radius) > 0) // Is the sphere at least *partially* in front of the origin?
        {
            float2 rectMin, rectMax;

            // For the 'x' and 'y' components, the solution is given below.
            if (g_isOrthographic)
            {
                // Compute the center and the extents (half-diagonal) of the bounding box.
                float2 center  = mul(projMat, float4(rbpC.xyz,     1)).xy;
                float2 extents = mul(projMat, float4(radius.xx, 0, 0)).xy;

                rectMin = center - extents;
                rectMax = center + extents;
            }
            else // Perspective
            {
                float2 xBounds = ComputeBoundsOfProjectedSphere(rbpC.xxz, radius, projMat._m00, projMat._m02); // X-Z plane
                float2 yBounds = ComputeBoundsOfProjectedSphere(rbpC.yyz, radius, projMat._m11, projMat._m12); // Y-Z plane

                rectMin = float2(xBounds.r, yBounds.r);
                rectMax = float2(xBounds.g, yBounds.g);
            }

            // Transform to the NDC coordinates.
            rectMin = rectMin * 0.5 + 0.5;
            rectMax = rectMax * 0.5 + 0.5;

            // Note: separating the X- and Y-computations across 2 threads is not worth it.
            ndcAaBbMinPt.xy = max(ndcAaBbMinPt.xy, rectMin);
            ndcAaBbMaxPt.xy = min(ndcAaBbMaxPt.xy, rectMax);
            // Skip Z, we do not need it.
            ndcAaBbMinPt.w  = max(ndcAaBbMinPt.w, rbpC.z - radius);
            ndcAaBbMaxPt.w  = min(ndcAaBbMaxPt.w, rbpC.z + radius);
        }
    }

    if (!isHelperThread && (t == 0)) // Avoid bank conflicts
    {
        _xyBoundsBuffer[bufferIndex] = float4(ndcAaBbMinPt.x, ndcAaBbMaxPt.x, ndcAaBbMinPt.y, ndcAaBbMaxPt.y);
        _wBoundsBuffer[bufferIndex]  = float2(ndcAaBbMinPt.w, ndcAaBbMaxPt.w);
    }
}
