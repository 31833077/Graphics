#pragma enable_d3d11_debug_symbols
#pragma only_renderers d3d11 playstation xboxone vulkan metal switch

// Generates large screen tiles in a fast, conservative manner.
#pragma kernel FillCoarseTiles     PASS = FILL_COARSE_TILES     COARSE_BINNING
// Removes certain entities from the coarse buffer at a large cost.
#pragma kernel PruneCoarseTiles    PASS = PRUNE_COARSE_TILES    COARSE_BINNING
// Generates small screen tiles in an accurate manner.
#pragma kernel FillFineTiles       PASS = FILL_FINE_TILES       FINE_BINNING

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition-config/Runtime/ShaderConfig.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesGlobal.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/TilingAndBinningUtilities.hlsl"

/* ------------------------------ Inputs ------------------------------------ */

#if (PASS == FILL_COARSE_TILES)
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    StructuredBuffer<float4> _xyBoundsBuffer : register(t0); // {x_min, x_max, y_min, y_max}
#endif

#if (PASS == PRUNE_COARSE_TILES)
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    StructuredBuffer<FiniteLightBound> _EntityBoundsBuffer  : register(t0);
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    StructuredBuffer<uint>             _SrcCoarseTileBuffer : register(t1); // Index range + index list
#endif

/* ------------------------------ Outputs ----------------------------------- */

#if (PASS == FILL_COARSE_TILES)
    // The tile buffer is composed of two parts:
    // the header (containing index ranges, 2 * sizeof(uint16)) and
    // the body (containing index lists, TiledLightingConstants.s_CoarseTileEntryLimit * sizeof(uint16)).
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    // The size of the buffer can be computed as follows:
    // DIV_ROUND_UP(RES_X, COARSE_TILE_SIZE) * DIV_ROUND_UP(RES_Y, COARSE_TILE_SIZE) *
    // BOUNDEDENTITYCATEGORY_COUNT * EYE_COUNT * (2 + COARSE_TILE_ENTRY_LIMIT) * 2 bytes per entry.
    // For example (1080p): 30 * 17 * 5 * 1 * (2 + 64) * 2 = 328.7 KiB.
    RWStructuredBuffer<uint> _CoarseTileBuffer : register(u0); // Index range + index list
#endif

#if (PASS == PRUNE_COARSE_TILES)
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    RWStructuredBuffer<uint> _DstCoarseTileBuffer : register(u0); // Index range + index list
#endif

#if (PASS == BUILD_FINE_TILES)
    // The tile buffer is composed of two parts:
    // the header (containing index ranges, 2 * sizeof(uint16)) and
    // the body (containing index lists, TiledLightingConstants.s_CoarseTileEntryLimit * sizeof(uint16)).
    // 1x list for all entites (sorted by category, we concatenate lists of all views).
    // The size of the buffer can be computed as follows:
    // DIV_ROUND_UP(RES_X, FINE_TILE_SIZE) * DIV_ROUND_UP(RES_Y, FINE_TILE_SIZE) *
    // BOUNDEDENTITYCATEGORY_COUNT * EYE_COUNT * (2 + FINE_TILE_ENTRY_LIMIT) * 2 bytes per entry.
    // For example (1080p): 240 * 165 * 5 * 1 * (2 + 16) * 2 = 6.8 MiB.
#endif

/* ------------------------------ Utilities --------------------------------- */

/* ------------------------------ Implementation ---------------------------- */

// !!! IMPORTANT !!!
// The legacy code from Morten provides us special projection matrices (and their inverses).
// These matrices are different from the matrices the HDRP uses.
// There is no reversed-Z buffering (effectively, forced UNITY_REVERSED_Z = 0).
// Additionally, there is no clip-space flip (effectively, forced UNITY_UV_STARTS_AT_TOP = 0).
// Therefore, all coordinate systems are left-handed, Y-up, without W-flip.
// Near and far planes are swapped in the case of Z-reversal, but it does not change the algorithm.
// y  z
// | /
// 0 -- x

#if (REMAINDER(TILE_ENTRY_LIMIT, 2) != 0)
    #error "TILE_ENTRY_LIMIT must be an integer multiple of 2."
#endif

#define THREADS_PER_GROUP (64)

// 1x thread per tile.
[numthreads(THREADS_PER_GROUP, 1, 1)]
void FillCoarseTiles(uint threadID : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    // We could tile the threads in 8x8 blocks. The problem is,
    // the dimensions of the buffer are already quite small. The extra padding
    // (helper threads) required outweighs the benefits (improved locality, reduced divergence).
    const uint t   = threadID;
    const uint g   = groupID.x;
    const uint cat = groupID.y;
    const uint eye = groupID.z;

    const uint  globalTileIndex  = IndexFromCoordinate(uint2(t, g), THREADS_PER_GROUP);
    const uint  clampedTileIndex = min(globalTileIndex, TILE_BUFFER_DIMS.x * TILE_BUFFER_DIMS.y - 1);
    const uint2 clampedTileCoord = CoordinateFromIndex(clampedTileIndex, TILE_BUFFER_DIMS.x);

    // Helper threads may perform the same computation on valid data,
    // but do not store the results of the computation to memory.
    const bool isHelperThread = globalTileIndex != clampedTileIndex;

    if (isHelperThread) return; // Avoid adding too many checks or branches below

    // Entities are sorted by category.
    const uint entityIndex = s_BoundedEntityOffsetPerCategory[cat];
    const uint entityCount = s_BoundedEntityCountPerCategory[cat];

    const uint inputStart  = ComputeEntityBoundsBufferIndex(entityIndex, eye);
    const uint outputStart = ComputeTileBufferBodyIndex(clampedTileIndex, cat, eye);

    uint first = UINT16_MAX, last = 0;

    if (entityCount > 0) // Avoid wasted work
    {
        // Compute 2-D the AABB of the tile.
        const uint2  tileAaBbMinPtSS  = clampedTileCoord * TILE_SIZE;
        const uint2  tileAaBbMaxPtSS  = tileAaBbMinPtSS  + TILE_SIZE;                   // (clampedTileCoord + 1) * TILE_SIZE
        const float2 tileAaBbMinPtNDC =          tileAaBbMinPtSS * _ScreenSize.zw;      // Divide
        const float2 tileAaBbMaxPtNDC = saturate(tileAaBbMaxPtSS * _ScreenSize.zw);     // Divide and clamp to the edge
        const float2 tileBoundsX      = float2(tileAaBbMinPtNDC.x, tileAaBbMaxPtNDC.x); // TODO: add epsilon for numerical robustness?
        const float2 tileBoundsY      = float2(tileAaBbMinPtNDC.y, tileAaBbMaxPtNDC.y); // TODO: add epsilon for numerical robustness?

        // Define inputs (i) and outputs (j).
        uint i = 0, j = 0;
        uint indexPair = 0;

        // The algorithm is O(n * m) where 'n' is the entity count and 'm' is tile count.
        // Therefore, it will be slow if 'n' is large.
        // We should consider a sorting-based algorithm, which could be closer to O((n + m) * log(n)).
        // TODO: unroll.
        while ((i < entityCount) && (j < TILE_ENTRY_LIMIT))
        {
            float2 entityBoundsX = _xyBoundsBuffer[inputStart + i].xy;
            float2 entityBoundsY = _xyBoundsBuffer[inputStart + i].zw;

            if (IntervalsOverlap(entityBoundsX, tileBoundsX) &&
                IntervalsOverlap(entityBoundsY, tileBoundsY))
            {
                // We store intra-category indices.
                first = min(i, first);
                last  = max(i, last);

                // 2x 16-bit indices per uint.
                indexPair |= i << (16 * (j & 1)); // First Lo, then Hi bits

                if ((j & 1) != 0) // Is the pair complete & ready to be stored?
                {
                    _CoarseTileBuffer[outputStart + (j / 2)] = indexPair;

                    indexPair = 0; // In order to use bitwise OR above
                }

                j++;
            }

            i++;
        }

        if (j < TILE_ENTRY_LIMIT)
        {
            i = UINT16_MAX; // Add a terminator

            indexPair |= i << (16 * (j & 1)); // First Lo, then Hi bits

            _CoarseTileBuffer[outputStart + (j / 2)] = indexPair;
        }
    }

    uint outputRange = (last << 16) | first;

    // Store the metadata.
    uint headerIndex = ComputeTileBufferHeaderIndex(clampedTileIndex, cat, eye);
    _CoarseTileBuffer[headerIndex] = outputRange;
}

// Below is copy-pasted from 'scrbound.compute'.
// Clipping a plane by a cube may produce a hexagon (6-gon).
// Clipping a hexagon by 4 planes (substitute a quad for the plane) may produce a decagon (10-gon).
#define MAX_CLIP_VERTS     (10)
#define NUM_VERTS          (8)
#define NUM_FACES          (6)
#define NUM_PLANES         (6)
#define THREADS_PER_GROUP  (64)
#define THREADS_PER_ENTITY (4) // Set to 1 for debugging
#define ENTITIES_PER_GROUP (THREADS_PER_GROUP / THREADS_PER_ENTITY)
#define VERTS_PER_GROUP    (NUM_VERTS * ENTITIES_PER_GROUP)
#define VERTS_PER_THREAD   (NUM_VERTS / THREADS_PER_ENTITY)
#define FACES_PER_THREAD   (DIV_ROUND_UP(NUM_FACES, THREADS_PER_ENTITY))
#define VERTS_PER_FACE     (4)

// Needs the defines above.
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/ClippingUtilities.hlsl"

// 5 arrays * 128 elements * 4 bytes each = 2560 bytes.
groupshared float gs_HapVertsX[VERTS_PER_GROUP];
groupshared float gs_HapVertsY[VERTS_PER_GROUP];
groupshared float gs_HapVertsZ[VERTS_PER_GROUP];
groupshared float gs_HapVertsW[VERTS_PER_GROUP];
groupshared uint  gs_BehindMasksOfVerts[VERTS_PER_GROUP]; // 6 planes each (HLSL does not support small data types)

#define THREADS_PER_TILE (THREADS_PER_ENTITY) // Helps with naming
#define TILES_PER_GROUP  (THREADS_PER_GROUP / THREADS_PER_TILE)

bool TryCullSphere(float3 center, float radius, float2 aaBbMinPtNDC, float2 aaBbMaxPtNDC, float4x4 projMat, float4x4 invProjMat)
{
    bool isCulled;

    // We do not consider the near and the far plane (as as in 'scrbound.compute').
    if (g_isOrthographic)
    {
        // Compute the center and the extents (half-diagonal) of the bounding box.
        float2 sphereCenterCS  = mul(projMat, float4(center,       1)).xy;
        float2 sphereExtentsCS = mul(projMat, float4(radius.xx, 0, 0)).xy; // Axis-aligned ellipse

        // Convert to clip-space coordinates.
        float2 aaBbMinPtCS = aaBbMinPtNDC * 2 - 1;
        float2 aaBbMaxPtCS = aaBbMaxPtNDC * 2 - 1;

        // Make them relative to the ellipse.
        aaBbMinPtCS -= sphereCenterCS;
        aaBbMaxPtCS -= sphereCenterCS;

        // Transform the ellipse into a unit circle.
        aaBbMinPtCS *= rcp(sphereExtentsCS);
        aaBbMaxPtCS *= rcp(sphereExtentsCS);

        // Compute the distance from the center of the sphere (at the origin) to the AABB.
        float sqDist = SqDistPointAaBb(0, aaBbMinPtCS, aaBbMaxPtCS);

        isCulled = sqDist > 1;
    }
    else // Perspective
    {
        // Extract the frustum planes? IDK...
        isCulled = false;
    }

    return isCulled;
}

bool TryCullEntity(uint entityIndex, uint category, uint eye, uint2 tileCoord, uint t /* thread */)
{
    const uint2  tileAaBbMinPtSS  = tileCoord       * TILE_SIZE;
    const uint2  tileAaBbMaxPtSS  = tileAaBbMinPtSS + TILE_SIZE;                // (tileCoord + 1) * TILE_SIZE
    const float2 tileAaBbMinPtNDC =          tileAaBbMinPtSS * _ScreenSize.zw;  // Divide
    const float2 tileAaBbMaxPtNDC = saturate(tileAaBbMaxPtSS * _ScreenSize.zw); // Divide and clamp to the edge

    const uint             bufferIndex = ComputeEntityBoundsBufferIndex(entityIndex, category, eye);
    const FiniteLightBound cullData    = _EntityBoundsBuffer[bufferIndex];

    const float4x4 projMat    = g_mProjectionArr[eye];    // For the entire view frustum
    const float4x4 invProjMat = g_mInvProjectionArr[eye]; // For the entire view frustum

    // Bounding frustum.
    const float3 rbpC  = cullData.center.xyz;   // View-space
    const float3 rbpX  = cullData.boxAxisX.xyz; // Pre-scaled
    const float3 rbpY  = cullData.boxAxisY.xyz; // Pre-scaled
    const float3 rbpZ  = cullData.boxAxisZ.xyz; // Pre-scaled
    const float scale  = cullData.scaleXY;      // scale.x = scale.y
    // Bounding sphere.
    const float radius = cullData.radius;

    bool trivialReject = false, trivialAccept = false;

    // 1. Attempt to trivially reject the entity by considering its bounding sphere.
    trivialReject = TryCullSphere(rbpC, radius, tileAaBbMinPtNDC, tileAaBbMaxPtNDC, projMat, invProjMat);

    return trivialReject;
}

// *************************************************************************************************
// At this point, each tile has a list of conservatively selected entities.
// The idea it to spend a few more clock cycles to remove entities that do not belong to the tile.
// We use roughly the same idea as in 'scrbound.compute':
// we test the bounding volume of the entity against the mini-frustum of the tile.
// The difference is that we do not need to compute the AABB.
// Thus, there is a "slow" path and a "fast" path. The latter includes "trivial" accept or reject.
// "trivial" accept or reject ..........
// *************************************************************************************************

[numthreads(THREADS_PER_TILE, TILES_PER_GROUP, 1)]
void PruneCoarseTiles(uint3 threadID : SV_GroupThreadID, uint3 groupID : SV_GroupID)
{
    // TODO: swizzle blocks of tiles to improve locality & reduce divergence at the cost of padding?
    const uint t    = threadID.x;
    const uint tile = threadID.y;
    const uint g    = groupID.x;
    const uint cat  = groupID.y;
    const uint eye  = groupID.z;

    const uint  globalTileIndex  = IndexFromCoordinate(uint2(tile, g), TILES_PER_GROUP);
    const uint  clampedTileIndex = min(globalTileIndex, TILE_BUFFER_DIMS.x * TILE_BUFFER_DIMS.y - 1);
    const uint2 clampedTileCoord = CoordinateFromIndex(clampedTileIndex, TILE_BUFFER_DIMS.x);

    const uint tileBufferHeaderIndex = ComputeTileBufferHeaderIndex(clampedTileIndex, cat, eye);
          uint tileRangeData         = _SrcCoarseTileBuffer[tileBufferHeaderIndex]; // {last << 16 | first}
    const bool isTileEmpty           = tileRangeData == UINT16_MAX;

    if (!isTileEmpty)
    {
        const uint tileBufferBodyIndex = ComputeTileBufferBodyIndex(clampedTileIndex, cat, eye);

        // Define inputs (i) and outputs (j).
        uint i = 0, j = 0;
        uint indexPair = 0;

        uint first = UINT16_MAX, last = 0;

        while (i < TILE_ENTRY_LIMIT)
        {
            uint entityPair  = _SrcCoarseTileBuffer[tileBufferBodyIndex + (i / 2)]; // 16-bit indices
            uint entityIndex = BitFieldExtract(entityPair, 16 * (i & 1), 16);       // First Lo, then Hi bits

            if (entityIndex == UINT16_MAX)
            {
                break; // Reached the terminator
            }

            if (!TryCullEntity(entityIndex, cat, eye, clampedTileCoord, t))
            {
                // The entity was not culled, so transfer it over.
                first = min(entityIndex, first);
                last  = max(entityIndex, last);

                // 2x 16-bit indices per uint.
                indexPair |= entityIndex << (16 * (j & 1)); // First Lo, then Hi bits

                if ((j & 1) != 0) // Is the pair complete & ready to be stored?
                {
                    _DstCoarseTileBuffer[tileBufferBodyIndex + (j / 2)] = indexPair;

                    indexPair = 0; // In order to use bitwise OR above
                }

                j++;
            }

            i++;
        }

        if (j < TILE_ENTRY_LIMIT)
        {
            uint entityIndex = UINT16_MAX; // Add a terminator

            indexPair |= entityIndex << (16 * (j & 1)); // First Lo, then Hi bits

            _DstCoarseTileBuffer[tileBufferBodyIndex + (j / 2)] = indexPair;
        }

        tileRangeData = (last << 16) | first;
    }

    _DstCoarseTileBuffer[tileBufferHeaderIndex] = tileRangeData;
}

[numthreads(THREADS_PER_GROUP, 1, 1)]
void FillFineTiles(uint threadID : SV_GroupIndex, uint3 groupID : SV_GroupID)
{

}
