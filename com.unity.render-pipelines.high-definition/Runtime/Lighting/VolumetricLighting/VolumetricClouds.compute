#pragma kernel RenderClouds
#pragma kernel CombineClouds

// HDRP generic includes
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/ShaderVariablesPhysicallyBasedSky.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsManager.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsUtilities.hlsl"

// Tile size of this compute
#define VOLUMETRIC_CLOUDS_TILE_SIZE 8
#define MOTION_DISTORTION 0.02
#define NUM_MULTI_SCATTERING_OCTAVES 2
#define WIND_MAX_SPEED 0.1

// Input textures
TEXTURE2D_X(_CameraColorTexture);
TEXTURE2D_X(_DepthTexture);
Texture2D<float4> _CloudMapTexture;
Texture2D<float2> _CloudLutTexture;
Texture3D<float4> _Worley128RGBA;

// Output texture
RW_TEXTURE2D_X(float4, _VolumetricCloudsTextureRW);

// Structure that holds all the data required for the cloudray ray marching
struct CloudRay
{
    // Origin of the ray in absolute world space
    float3 origin;
    // Direction of the ray in world space
    float3 direction;
    // Maximal ray length before hitting the far plane or an occluder
    float maxRayLength;
};

CloudRay BuildRay(uint2 currentCoord)
{
    // Read the depth value
    float depthValue = LOAD_TEXTURE2D_X(_DepthTexture, currentCoord).r;

    // Compute the NDC position
    float2 positionNDC = (currentCoord + 0.5) * _ScreenSize.zw;

    // Build the ray
    CloudRay ray;
    // Is this a sky pixel?
    if (depthValue == UNITY_RAW_FAR_CLIP_VALUE)
    {
        // Compute a virtual position that we'll use for our direction generation
        float3 positionWS = ComputeWorldSpacePosition(positionNDC, 0.5f, UNITY_MATRIX_I_VP);
        ray.direction = normalize(positionWS);
        ray.maxRayLength = _ProjectionParams.z; // Far plane
    }
    else
    {
        // Compute the world space position of the occluder
        float3 positionWS = ComputeWorldSpacePosition(positionNDC, depthValue, UNITY_MATRIX_I_VP);
        // Compute the view vector of the camera
        ray.maxRayLength = length(positionWS);
        // Compute the ray direction
        ray.direction = positionWS / ray.maxRayLength;
    }

    // The ray is cast from the camera
    ray.origin = _WorldSpaceCameraPos;

    return ray;
}

float2 IntersectAABB(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax)
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

bool PointInsideCloudVolumeAABB(float3 positionWS)
{
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float eps = 1e-4;
    return  (positionWS.x > minCorner.x-eps) && (positionWS.y > minCorner.y-eps) && (positionWS.z > minCorner.z-eps) && 
            (positionWS.x < maxCorner.x+eps) && (positionWS.y < maxCorner.y+eps) && (positionWS.z < maxCorner.z+eps);
}

bool GetCloudVolumeIntersection(float3 org, float3 dir, out float distToStart, out float totalDistance)
{
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float2 intersections = IntersectAABB(org, dir, minCorner, maxCorner);
    
    if(PointInsideCloudVolumeAABB(org))
        intersections.x = 1e-4;
    
    distToStart = intersections.x;
    totalDistance = intersections.y - intersections.x;
    return intersections.x > 0.0 && (intersections.x < intersections.y);
}

// Structure that holds all the data used to define the cloud density of a point in space
struct CloudCoverageData
{
    // From a top down view, in what proportions this pixel has clouds
    float coverage;
    // From a top down view, in what proportions this pixel has clouds
    float rainClouds;
    // Value that allows us to request the cloudtype using the density
    float cloudType;
};

void GetCloudCoverageData(float3 positionWS, out CloudCoverageData data)
{
    // Convert the position into dome space
    float2 normalizedPosition = saturate(positionWS.xz / _CloudDomeSize * 0.5 + 0.5);
    // Exclude the limits of the dome
    normalizedPosition = clamp(normalizedPosition, 0.001, 0.999);
    // Read the data from the texture
    float4 cloudMapData =  SAMPLE_TEXTURE2D_LOD(_CloudMapTexture, s_linear_clamp_sampler, float2(normalizedPosition), 0.0);
    // Fill the coverage data
    data.coverage = cloudMapData.x;
    data.rainClouds = cloudMapData.y;
    data.cloudType = cloudMapData.z;
}

// Structure that holds all the lighting data required to light the cloud particles
struct EnvironmentLighting
{
    // Light direction (point to sun)
    float3 sunDirection;
    // Light intensity/color of the sun, this already takes into account the atmospheric scattering
    float3 sunColor;
    // Ambient term from the ambient probe
    float3 ambientTerm;
};

EnvironmentLighting EvaluateEnvironmentLighting(CloudRay ray)
{
    // Sun parameters
    EnvironmentLighting environmentLight;
    environmentLight.sunDirection = _SunDirection;
    environmentLight.sunColor = _SunLightColor * (_ExposureSunColor ? GetCurrentExposureMultiplier() : 1.0);
    environmentLight.ambientTerm = SampleSH9(_AmbientProbeCoeffs, ray.direction) * GetCurrentExposureMultiplier();

    // TODO: move this into a shared function
    {
        // TODO: should probably unify height attenuation somehow...
        // TODO: Not sure it's possible to precompute cam rel pos since variables
        // in the two constant buffers may be set at a different frequency?
        float3 X = ray.origin;
        float3 C = _PlanetCenterPosition.xyz;

        float r        = distance(X, C);
        float cosHoriz = ComputeCosineOfHorizonAngle(r);
        float cosTheta = dot(X - C, environmentLight.sunDirection) * rcp(r); // Normalize

        if (cosTheta >= cosHoriz) // Above horizon
        {
            float3 oDepth = ComputeAtmosphericOpticalDepth(r, cosTheta, true);
            // Cannot do this once for both the sky and the fog because the sky may be desaturated. :-(
            float3 transm  = TransmittanceFromOpticalDepth(oDepth);
            float3 opacity = 1 - transm;
            environmentLight.sunColor.rgb *= 1 - (Desaturate(opacity, _AlphaSaturation) * _AlphaMultiplier);
        }
        else
        {
            // return 0; // Kill the light. This generates a warning, so can't early out. :-(
           environmentLight.sunColor = 0;
        }
    }
    return environmentLight;
}

struct CloudProperties
{
    // Normalized float that tells is the "amount" of clouds that is at a given location
    float density;
    // Normalized value that tells us the height within the cloud volume (vertically)
    float height;
};

void EvaluateCloudProperties(float3 positionWS, bool cheapVersion, out CloudProperties properties)
{
    // Initliaze all the values to 0 in case
    ZERO_INITIALIZE(CloudProperties, properties);

    // If the next sampling point is not inside the AABB, the density is already set to 0, we can skip right away.
    if (!PointInsideCloudVolumeAABB(positionWS))
        return;

    // Evaluate the cloud coverage data for this position
    CloudCoverageData cloudCoverageData;
    GetCloudCoverageData(positionWS, cloudCoverageData);

    // If this region of space has no cloud coverage, exit right away
    if (cloudCoverageData.coverage <= 0.0)
        return;
    
    // Evaluate the normalized height of the position within the cloud volume
    properties.height = saturate((positionWS.y - _LowestCloudAltitude) / (_HighestCloudAltitude - _LowestCloudAltitude));

    // Pre-fetch the density as early as posisble
    float densityHeightGradient = SAMPLE_TEXTURE2D_LOD(_CloudLutTexture, s_linear_clamp_sampler, float2(cloudCoverageData.cloudType, properties.height), 0.0).x;

    // Evaluate the coordinates at which the noise will be sampled and apply wind displacement
    float3 noiseSamplingCoordinates = positionWS.xzy / (_CloudDomeSize * 2.0) * 10.0f + _WindDirection * _Time.y * WIND_MAX_SPEED * _WindSpeed;

    // Distortion of the upper strats of the cloud laer  
    noiseSamplingCoordinates += properties.height * _WindDirection * MOTION_DISTORTION;

    // Read the low frequency Perlin-Worley and Worley noises
    float4 lowFrequencyNoises = SAMPLE_TEXTURE3D_LOD(_Worley128RGBA, s_trilinear_repeat_sampler, noiseSamplingCoordinates.xyz, 0.0);
    float lowFreqFBm = ( lowFrequencyNoises.y * 0.625 ) + ( lowFrequencyNoises.z * 0.25 ) + ( lowFrequencyNoises.w * 0.125);
    float base_cloud = remap(lowFrequencyNoises.x, 0.0, 1.0, -(1.0 - lowFreqFBm), 1.0);

    // We want bigger clouds to have higher density than smaller ones
    base_cloud += cloudCoverageData.cloudType * cloudCoverageData.cloudType * _DensityAmplifier;
    // The rain factor increases density at lower heights
    base_cloud += lerp(cloudCoverageData.rainClouds, 0.0, properties.height);

    // Saturate the result
    base_cloud = saturate(base_cloud);
    
    // Apply the height function to the base cloud shape
    base_cloud *= densityHeightGradient.x;

    // Multiply the result by the cloud coverage so that the smaller clouds are lighter and more esthetically pleasing
    base_cloud *= cloudCoverageData.coverage;

    // Attenuate everything by the density multiplier
    properties.density = base_cloud * _DensityMultiplier;
}

float3 EvaluateSunLuminance(float3 position, EnvironmentLighting environmentLighting, float density, float powderEffect, float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES])
{
    // Compute the Ray to the limits of the cloud volume in the direction of the light
    float lightRayDistance = 0.0f;
    float distToStart = 0.0;
    GetCloudVolumeIntersection(position, environmentLighting.sunDirection, distToStart, lightRayDistance);
    
    // Compute the step of the light integration
    float stepL = lightRayDistance/(float)_NumLightSteps;

    // Initially the transmittance is one
    float3 sunLightTransmittance[NUM_MULTI_SCATTERING_OCTAVES];
    int o;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        sunLightTransmittance[o] = 1.0;

    // Collect total density along light ray.
    for (int j = 0; j < _NumLightSteps; j++)
    {
        // Evaluate the current sample point
        float3 currentSamplePoint = position + environmentLighting.sunDirection * (float)j * stepL;

        // Get the cloud properties at the sample point
        CloudProperties lightRayCloudProperties;
        EvaluateCloudProperties(currentSamplePoint, true, lightRayCloudProperties);

        const float3 sigmaE = max(_ScatteringTint, float3(1e-6, 1e-6, 1e-6));

        for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
            sunLightTransmittance[o] *= exp(- stepL * lightRayCloudProperties.density * sigmaE * pow(_MultiScattering, o));
    }
    
    float3 luminance = 0.0;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
         luminance += sunLightTransmittance[o] * environmentLighting.sunColor * powderEffect * phaseFunction[o] * pow(_MultiScattering, o);

    return luminance;
}

float4 TraceVolumetricRay(float3 rayOrigin, float3 rayDirection, float maxRayLength,
                            EnvironmentLighting environmentLighting, float offset)
{    
    // Determine if ray intersects bounding volume, if the ray does not intersect the cloud volume AABB, skip right away
    float startDistance = 0.0;
    float totalDistance = 0.0;
    if (!GetCloudVolumeIntersection(rayOrigin, rayDirection, startDistance, totalDistance))
        return float4(0.0, 0.0, 0.0, 1.0);

    // Clamp the travel distance to whatever is closer
    // - Sky Occluder
    // - Volume end
    // - Far plane
    totalDistance = min(totalDistance, maxRayLength - startDistance);

    // Evaluate our integration step
    float stepS = totalDistance / (float)_NumPrimarySteps; 
    
    // Offset the starting point using our dithering pattern.
    startDistance += stepS * offset;
    
    // Evaluate cos of the theta angle between the view and light vectors
    float cosAngle = dot(rayDirection, environmentLighting.sunDirection);

    // Evaluate the phase function for our ray direction

    float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES];
    for(int o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
    {
        const float forwardP = HenyeyGreenstein(cosAngle, _EccentricityF * pow(_MultiScattering, o));
        const float backwardsP = HenyeyGreenstein(cosAngle, -_EccentricityB * pow(_MultiScattering, o));
        phaseFunction[o] = lerp(forwardP, backwardsP, _PhaseFunctionBlend);
    }

    // Initialize the integration values
    float4 intScattTrans = float4(0.0, 0.0, 0.0, 1.0);
    float3 initialPosition = rayOrigin + startDistance * rayDirection;

    // Do the ray march for every step that we can.
    for(int i = 0; i < _NumPrimarySteps; i++)
    {
        // Compute the position of the current sample
        float3 position = initialPosition + rayDirection * i * stepS;

        // Evaluate the density and height at the current ray marching point
        CloudProperties cloudProperties;
        EvaluateCloudProperties(position, false, cloudProperties);

        // If the density is null, we can skip as there will be no contribution
        if (cloudProperties.density > 0.0)
        {
            const float3 clampedExtinction = max(cloudProperties.density, 0.0000001);
            const float currentStepExtinction = exp(- cloudProperties.density * stepS);

            float powder_effect = PowderEffect(cloudProperties.density, cosAngle, _PowderEffectIntensity);
            const float3 sunLuminance = (EvaluateSunLuminance(position, environmentLighting, cloudProperties.density, powder_effect, phaseFunction) + environmentLighting.ambientTerm) * cloudProperties.density;
            // THINK about multiplication with shadow map

            const float3 luminance = sunLuminance;
            const float3 integScatt = (luminance - luminance * currentStepExtinction) / clampedExtinction;
            
            intScattTrans.rgb += integScatt * intScattTrans.a;
            intScattTrans.a *= currentStepExtinction; 
        }
    }

    return intScattTrans;
}

[numthreads(VOLUMETRIC_CLOUDS_TILE_SIZE, VOLUMETRIC_CLOUDS_TILE_SIZE, 1)]
void RenderClouds(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Compute the pixel position to process
    uint2 currentCoord = groupId * VOLUMETRIC_CLOUDS_TILE_SIZE + groupThreadId;

    // Build the ray we will use of the ray marching.
    CloudRay ray = BuildRay(currentCoord);

    // Compute the environment lighting that is going to be used for the cloud evaluation
    EnvironmentLighting environmentLight = EvaluateEnvironmentLighting(ray);
    
    // We use the Heitz blue noise method for dithering to get the most visually pleasing noise.
    float offset = GetBNDSequenceSample(currentCoord, _AccumulationFrameIndex, 0);
    
    // Evaluate the cloud transmittance
    float4 finalColor = TraceVolumetricRay(ray.origin, ray.direction, ray.maxRayLength, environmentLight, offset); 

    // output the result
    _VolumetricCloudsTextureRW[COORD_TEXTURE2D_X(currentCoord)] = finalColor;
}

TEXTURE2D_X(_VolumetricCloudsTexture);
TEXTURE2D_X(_HistoryVolumetricCloudsTexture);
RW_TEXTURE2D_X(float4, _CameraColorTextureRW);
RW_TEXTURE2D_X(float4, _HistoryVolumetricCloudsTextureRW);

[numthreads(VOLUMETRIC_CLOUDS_TILE_SIZE, VOLUMETRIC_CLOUDS_TILE_SIZE, 1)]
void CombineClouds(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 currentCoord = groupId * VOLUMETRIC_CLOUDS_TILE_SIZE + groupThreadId;

    // Compute the history tap coordinate for this pixel
    float2 velocity = float2(0.0, 0.0);
    DecodeMotionVector(LOAD_TEXTURE2D_X(_CameraMotionVectorsTexture, (float2)currentCoord), velocity);
    float2 positionNDC = (currentCoord + 0.5) * _ScreenSize.zw;
    float2 historyTapCoord = (float2)(positionNDC - velocity) * _ScreenSize.xy;

    // Read the volumetric cloud value from the previous frame
    float4 previousResult = SAMPLE_TEXTURE2D_X_LOD(_HistoryVolumetricCloudsTexture, s_linear_clamp_sampler, historyTapCoord * _ScreenSize.zw * _RTHandleScaleHistory.zw, 0);

    // Read the volumetric cloud value produced by this frame
    float4 currentResult = LOAD_TEXTURE2D_X(_VolumetricCloudsTexture, currentCoord);

    // Accumuate both values
    float accumulationFactor = 0.8;

    if (historyTapCoord.x < 0.0 || historyTapCoord.x >= _ScreenSize.x || historyTapCoord.y < 0.0 || historyTapCoord.y >= _ScreenSize.y)
        accumulationFactor = 0.0;

    float4 cloudResult = accumulationFactor * previousResult + (1.0 - accumulationFactor) * currentResult;

    // Read the current frame buffer
    float4 currentColor = _CameraColorTextureRW[COORD_TEXTURE2D_X(currentCoord)];

    // Combine everything and output the values
    _CameraColorTextureRW[COORD_TEXTURE2D_X(currentCoord)] = currentColor * cloudResult.a + float4(cloudResult.rgb, 0.0);
    _HistoryVolumetricCloudsTextureRW[COORD_TEXTURE2D_X(currentCoord)] = cloudResult;
}