#pragma kernel RenderClouds
#pragma kernel ReprojectClouds
#pragma kernel UpscaleAndCombineClouds

// #pragma enable_d3d11_debug_symbols

// HDRP generic includes
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/ShaderVariablesPhysicallyBasedSky.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsManager.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/ScreenSpaceLighting/BilateralUpsample.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsUtilities.hlsl"

// The vertical distortion as upper strat-clouds move faster than lower strats
#define MOTION_DISTORTION 0.04
// The number of octaves for the multi-scattering
#define NUM_MULTI_SCATTERING_OCTAVES 2
// Max speed in normalized space
#define WIND_MAX_SPEED 0.04
// Bias in the light sample distribution to exagerate the darkening effect of the clouds
#define WEIGHTED_LIGHT_SAMPLE_DISTRIBUTION_FACTOR 1.5f
// The number of times the low frequency noise is repeated
#define CLOUD_SCALE_FACTOR 2.0
// The number of times the high frequency noise is repeated
#define EROSION_SCALE_FACTOR 15.0
// Global offset to the high frequency noise
#define CLOUD_DETAIL_MIP_OFFSET 1.0
// Density blow wich we consider the density is zero (optimization reasons)
#define CLOUD_DENSITY_TRESHOLD 0.001f
// Number of steps before we start the large steps
#define EMPTY_STEPS_BEFORE_LARGE_STEPS 2
// Forward eccentricity
#define FORWARD_ECCENTRICITY 0.8
// Forward eccentricity
#define BACKWARD_ECCENTRICITY 0.5
// Define if the clouds are done in the camera-centric mode
#define CAMERA_CENTRIC_CLOUDS

// Input textures
Texture2D<float4> _CloudMapTexture;
Texture2D<float2> _CloudLutTexture;
Texture3D<float2> _Worley128RGBA;
Texture3D<float> _Worley32RGB;

// Output textures
RW_TEXTURE2D_X(float4, _CloudsLightingTextureRW);

// Structure that holds all the data required for the cloudray ray marching
struct CloudRay
{
    // Origin of the ray in absolute world space
    float3 origin;
    // Direction of the ray in world space
    float3 direction;
    // Maximal ray length before hitting the far plane or an occluder
    float maxRayLength;
};

CloudRay BuildRay(uint2 halfResCoord)
{
    // Compute the NDC position
    float2 positionNDC = (halfResCoord + 0.5) * _IntermediateScreenSize.zw;

    // Build the ray
    CloudRay ray;

    // Compute a virtual position that we'll use for our direction generation
    float3 positionWS = ComputeWorldSpacePosition(positionNDC, 0.5f, UNITY_MATRIX_I_VP);
    ray.direction = normalize(positionWS);
    ray.maxRayLength = _MaxCloudDistance;
#ifdef CAMERA_CENTRIC_CLOUDS
    // The ray is cast from the camera
    ray.origin = float3(_WorldSpaceCameraPos.x, _EarthRadius, _WorldSpaceCameraPos.z);
#else
    // The ray is cast from the camera
    ray.origin = _WorldSpaceCameraPos;
#endif

    return ray;
}

bool RaySphereIntersection(float3 start, float3 dir, float radius, out float result)
{
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    result = 0.0;
    if (d < 0.0)
        return false;
    result = (-b + sqrt(d))/(2.0*a);
    return true;
}

float2 IntersectAABB(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax)
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

bool PointInsideCloudVolume(float3 positionWS)
{
#ifdef CAMERA_CENTRIC_CLOUDS
    float distanceToeathCenter = length(positionWS);
    return (distanceToeathCenter < (_HighestCloudAltitude + _EarthRadius)) && (distanceToeathCenter > (_LowestCloudAltitude + _EarthRadius));
#else
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float eps = 1e-4;
    return  (positionWS.x > minCorner.x-eps) && (positionWS.y > minCorner.y-eps) && (positionWS.z > minCorner.z-eps) &&
            (positionWS.x < maxCorner.x+eps) && (positionWS.y < maxCorner.y+eps) && (positionWS.z < maxCorner.z+eps);
#endif
}

bool GetCloudVolumeIntersection(float3 org, float3 dir, out float distToStart, out float totalDistance)
{
#ifdef CAMERA_CENTRIC_CLOUDS
    float intersection0, intersection1;
    RaySphereIntersection(org, dir, _LowestCloudAltitude + _EarthRadius, intersection0);
    RaySphereIntersection(org, dir, _HighestCloudAltitude + _EarthRadius, intersection1);

    // If we are doing a light ray, we need to max this with 0 as we will be leaving the cloud layer
    intersection0 = max(intersection0, 0);
    distToStart = intersection0;
    totalDistance = intersection1 - intersection0;
    return true;
#else
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float2 intersections = IntersectAABB(org, dir, minCorner, maxCorner);

    if(PointInsideCloudVolume(org))
        intersections.x = 1e-4;

    distToStart = intersections.x;
    totalDistance = intersections.y - intersections.x;
    return intersections.x > 0.0 && (intersections.x < intersections.y);
#endif
}

// Structure that holds all the data used to define the cloud density of a point in space
struct CloudCoverageData
{
    // From a top down view, in what proportions this pixel has clouds
    float coverage;
    // From a top down view, in what proportions this pixel has clouds
    float rainClouds;
    // Value that allows us to request the cloudtype using the density
    float cloudType;
};

float3 AnimateCloudMapPosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _TimeParameters.x * _LargeWindSpeed;
}

float3 AnimateBaseNoisePosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _TimeParameters.x * _MediumWindSpeed;
}

float3 AnimateFineNoisePosition(float3 positionWS)
{
    return positionWS + float3(_WindVector.x, 0.0, _WindVector.y) * _TimeParameters.x * _SmallWindSpeed;
}

void GetCloudCoverageData(float3 positionWS, out CloudCoverageData data)
{
    // Convert the position into dome space
    float2 normalizedPosition = AnimateCloudMapPosition(positionWS).xz / _CloudDomeSize * 0.5 + 0.5;
    // Read the data from the texture
    float3 cloudMapData =  SAMPLE_TEXTURE2D_LOD(_CloudMapTexture, s_linear_repeat_sampler, float2(normalizedPosition), _CloudMapOffset).xyz;
    float renderRange = length(positionWS.xz) < (_CloudDomeSize * 2.0f) ? cloudMapData : 0.0f;
    data.coverage = lerp(0.0, cloudMapData.x, renderRange);
    data.rainClouds = lerp(0.0, cloudMapData.y, renderRange);
    data.cloudType = lerp(0.0, cloudMapData.z, renderRange);
}

// Structure that holds all the lighting data required to light the cloud particles
struct EnvironmentLighting
{
    // Light direction (point to sun)
    float3 sunDirection;
    // Light intensity/color of the sun, this already takes into account the atmospheric scattering
    float3 sunColor;
    // Ambient term from the ambient probe
    float3 ambientTerm;
};

EnvironmentLighting EvaluateEnvironmentLighting(CloudRay ray)
{
    // Sun parameters
    EnvironmentLighting environmentLight;
    environmentLight.sunDirection = _SunDirection;
    environmentLight.sunColor = _SunLightColor * (_ExposureSunColor ? GetCurrentExposureMultiplier() : 1.0);
    environmentLight.ambientTerm = SampleSH9(_AmbientProbeCoeffs, ray.direction) * GetCurrentExposureMultiplier();

    if(_PhysicallyBasedSun == 1)
    // TODO: move this into a shared function
    {
        #ifdef CAMERA_CENTRIC_CLOUDS
        float3 X = ray.origin - float3(0.0, _EarthRadius, 0.0);
        #else
        float3 X = ray.origin;
        #endif
        float3 C = _PlanetCenterPosition.xyz;

        float r        = distance(X, C);
        float cosHoriz = ComputeCosineOfHorizonAngle(r);
        float cosTheta = dot(X - C, environmentLight.sunDirection) * rcp(r); // Normalize

        if (cosTheta >= cosHoriz) // Above horizon
        {
            float3 oDepth = ComputeAtmosphericOpticalDepth(r, cosTheta, true);
            // Cannot do this once for both the sky and the fog because the sky may be desaturated. :-(
            float3 transm  = TransmittanceFromOpticalDepth(oDepth);
            float3 opacity = 1 - transm;
            environmentLight.sunColor.rgb *= 1 - (Desaturate(opacity, _AlphaSaturation) * _AlphaMultiplier);
        }
        else
        {
            // return 0; // Kill the light. This generates a warning, so can't early out. :-(
           environmentLight.sunColor = 0;
        }
    }
    return environmentLight;
}

struct CloudProperties
{
    // Normalized float that tells the "amount" of clouds that is at a given location
    float density;
    // Normalized value that tells us the height within the cloud volume (vertically)
    float height;
    // Transmittance of the cloud
    float sigmaT;
};

void EvaluateCloudProperties(float3 positionWS, float noiseMipOffset, bool cheapVersion, out CloudProperties properties)
{
    // Initliaze all the values to 0 in case
    ZERO_INITIALIZE(CloudProperties, properties);

    // If the next sampling point is not inside the AABB, the density is already set to 0, we can skip right away.
    if (!PointInsideCloudVolume(positionWS))
        return;

    // Evaluate the cloud coverage data for this position
    CloudCoverageData cloudCoverageData;
    GetCloudCoverageData(positionWS, cloudCoverageData);

    // If this region of space has no cloud coverage, exit right away
    if (cloudCoverageData.coverage <= CLOUD_DENSITY_TRESHOLD)
        return;

#ifdef CAMERA_CENTRIC_CLOUDS
    // Evaluate the normalized height of the position within the cloud volume
    properties.height = (length(positionWS) - (_LowestCloudAltitude + _EarthRadius)) / ((_HighestCloudAltitude + _EarthRadius) - (_LowestCloudAltitude + _EarthRadius));
#else
    // Evaluate the normalized height of the position within the cloud volume
    properties.height = saturate((positionWS.y - _LowestCloudAltitude) / (_HighestCloudAltitude - _LowestCloudAltitude));
#endif

    // Pre-fetch the density as early as posisble
    float densityHeightGradient = SAMPLE_TEXTURE2D_LOD(_CloudLutTexture, s_linear_clamp_sampler, float2(cloudCoverageData.cloudType, properties.height), 0.0).x;

    // Evaluate the generic sampling coordinates
    float3 baseNoiseSamplingCoordinates = float3(AnimateBaseNoisePosition(positionWS).xzy / _CloudDomeSize);

    // Evaluate the coordinates at which the noise will be sampled and apply wind displacement
    float3 lowFreqSamplingCoord = baseNoiseSamplingCoordinates * CLOUD_SCALE_FACTOR * 0.5 + 0.5;

    // Distortion of the upper strats of the cloud laer
    lowFreqSamplingCoord += properties.height * float3(_WindDirection.x, 0.0f, _WindDirection.y) * MOTION_DISTORTION;

    // Read the low frequency Perlin-Worley and Worley noises
    float2 lowFrequencyNoises = SAMPLE_TEXTURE3D_LOD(_Worley128RGBA, s_trilinear_repeat_sampler, lowFreqSamplingCoord.xyz, noiseMipOffset);
    float base_cloud = remap(lowFrequencyNoises.x, 0.0, 1.0, -(1.0 - lowFrequencyNoises.y), 1.0);

    // We want bigger clouds to have higher density than smaller ones
    base_cloud += cloudCoverageData.cloudType * cloudCoverageData.cloudType * _DensityAmplifier;

    // The rain factor increases density at lower heights
    base_cloud += lerp(cloudCoverageData.rainClouds, 0.0, properties.height);

    // Apply the height function to the base cloud shape
    base_cloud *= densityHeightGradient;

    // Multiply the result by the cloud coverage so that the smaller clouds are lighter and more esthetically pleasing
    base_cloud *= cloudCoverageData.coverage;

    // Apply the erosion for nifer details
    if (!cheapVersion)
    {
        float3 fineNoiseSamplingCoordinates = float3(AnimateFineNoisePosition(positionWS).xz / _CloudDomeSize, properties.height);

        // Evaluate the coordinates at which the noise will be sampled and apply wind displacement
        float3 highFreqSamplingCoord = fineNoiseSamplingCoordinates * EROSION_SCALE_FACTOR;

        float highFrequencyNoise = SAMPLE_TEXTURE3D_LOD(_Worley32RGB, s_linear_repeat_sampler, highFreqSamplingCoord, CLOUD_DETAIL_MIP_OFFSET).x;
        highFrequencyNoise *= smoothstep(0.0, 1.0, highFrequencyNoise) * lerp(0.0, _ErosionFactor,properties.height);
        base_cloud -= (highFrequencyNoise);
    }


    // Change the sigma based on the rain cloud data
    properties.sigmaT = lerp(0.04, lerp(0.06, 0.12, cloudCoverageData.rainClouds), cloudCoverageData.cloudType);
    properties.sigmaT = 0.04;
    // Make sure we do not send any negative values
    base_cloud = max(0, base_cloud);

    // Attenuate everything by the density multiplier
    properties.density = base_cloud * _DensityMultiplier;
}

float3 EvaluateSunLuminance(float3 position, in EnvironmentLighting envLighting, float density, float powderEffect, float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES])
{
    // Compute the Ray to the limits of the cloud volume in the direction of the light
    float lightRayDistance = 0.0f;
    float distToStart = 0.0;
    GetCloudVolumeIntersection(position, envLighting.sunDirection, distToStart, lightRayDistance);

    // Initially the transmittance is one for all octaves
    float3 sunLightTransmittance[NUM_MULTI_SCATTERING_OCTAVES];
    int o;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        sunLightTransmittance[o] = 1.0;

    // Collect total density along light ray.
    float lastDist = 0;
    for (int j = 1; j <= _NumLightSteps; j++)
    {
        // The samples are not linearly distributed along the point-light direction due to their low number. We sample they in a logarithmic way.
        float dist = lightRayDistance * PositivePow(j / (float)_NumLightSteps, WEIGHTED_LIGHT_SAMPLE_DISTRIBUTION_FACTOR);

        // Compute the size of the current step
        float stepSize =  (dist - lastDist);

        // Evaluate the current sample point
        float3 currentSamplePoint = position + envLighting.sunDirection * dist;
        // Get the cloud properties at the sample point
        CloudProperties lightRayCloudProperties;
        EvaluateCloudProperties(currentSamplePoint, 7.0f * j / _NumLightSteps, true, lightRayCloudProperties);

        // Compute the extinction
        const float3 mediaExtinction = max(lightRayCloudProperties.density * lightRayCloudProperties.sigmaT, float3(1e-6, 1e-6, 1e-6));

        // Update the transmittance for every octave
        for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
            sunLightTransmittance[o] *= exp(- stepSize * mediaExtinction * PositivePow(_MultiScattering, o));

        // Update the previous distance
        lastDist = dist;
    }

    // Compute the luminance for each octave
    float3 luminance = 0.0;
    for(o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        luminance += sunLightTransmittance[o] * envLighting.sunColor * powderEffect * phaseFunction[o] * PositivePow(_MultiScattering, o);

    // return the combined luminance
    return luminance;
}

// Structure that holds the result of our volumetric ray
struct VolumetricRayResult
{
    float3 inScattering;
    float transmittance;
    float meanDepth;
};

VolumetricRayResult TraceVolumetricRay(float3 rayOrigin, float3 rayDirection, float maxRayLength, EnvironmentLighting environmentLighting, float offset)
{
    // Initiliaze the volumetric ray
    VolumetricRayResult volumetricRay;
    volumetricRay.inScattering = 0.0;
    volumetricRay.transmittance = 1.0;
    volumetricRay.meanDepth = _MaxCloudDistance;

    // Determine if ray intersects bounding volume, if the ray does not intersect the cloud volume AABB, skip right away
    float startDistance = 0.0;
    float totalDistance = 0.0;
    if (!GetCloudVolumeIntersection(rayOrigin, rayDirection, startDistance, totalDistance))
        return volumetricRay;

    // Initialize the depth for accumulation
    volumetricRay.meanDepth = 0.0;

    // Clamp the travel distance to whatever is closer
    // - Sky Occluder
    // - Volume end
    // - Far plane
    totalDistance = min(totalDistance, maxRayLength - startDistance);

    // Evaluate our integration step
    float stepS = totalDistance / (float)_NumPrimarySteps;

    // Offset the starting point using our dithering pattern.
    startDistance += stepS * offset;

    // Evaluate cos of the theta angle between the view and light vectors
    float cosAngle = dot(rayDirection, environmentLighting.sunDirection);

    // Evaluate the phase function for our ray direction
    float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES];
    for(int o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
    {
        const float forwardP = HenyeyGreenstein(cosAngle,  FORWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
        const float backwardsP = HenyeyGreenstein(cosAngle, -BACKWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
        phaseFunction[o] = lerp(backwardsP, forwardP, _ScatteringDirection);
    }

    // Initialize the integration values
    float3 position = rayOrigin + startDistance * rayDirection;

    // Normalization value of the depth
    float meanDepthDivider = 0.0f;

    // Initialize the cloud properties structure
    CloudProperties cloudProperties;
    ZERO_INITIALIZE(CloudProperties, cloudProperties);

    // Initialize the values for the optimized ray marching
    bool activeSampling = false;
    float stepMultiplier = 2.0f;
    int sequentialEmptySamples = 0;

    // Do the ray march for every step that we can.
    for(int i = 0; i < _NumPrimarySteps; i++)
    {
        // Should we be evaluating the clouds or just doing the large ray marching
        if (activeSampling)
        {
            // If the density is null, we can skip as there will be no contribution
            EvaluateCloudProperties(position, 0.0f, false, cloudProperties);
            if (cloudProperties.density > CLOUD_DENSITY_TRESHOLD)
            {
                // Apply the extinction
                const float3 mediaExtinction = cloudProperties.density * cloudProperties.sigmaT;
                const float currentStepExtinction = exp(-mediaExtinction * stepS);

                // Compute the powder effect
                float powder_effect = PowderEffect(cloudProperties.density, cosAngle, _PowderEffectIntensity);
                // Evaluate the luminance at this sample
                const float3 luminance = (EvaluateSunLuminance(position, environmentLighting, cloudProperties.density, powder_effect, phaseFunction)
                                            + environmentLighting.ambientTerm) * mediaExtinction;

                // Improved analytical scattering
                const float3 integScatt = (luminance - luminance * currentStepExtinction) / mediaExtinction;
                volumetricRay.inScattering += integScatt * volumetricRay.transmittance;
                volumetricRay.transmittance *= currentStepExtinction;

                // TODO Compute the average depth
                /*
                // Contribute to the average depth
                float transmitanceXdensity = volumetricRay.transmittance * cloudProperties.density;
                volumetricRay.meanDepth += ( i * stepS + startDistance) * transmitanceXdensity;
                meanDepthDivider += transmitanceXdensity;
                */

                // Reset the empty sample counter
                sequentialEmptySamples = 0;
            }
            else
                sequentialEmptySamples++;

            // If it has been more than EMPTY_STEPS_BEFORE_LARGE_STEPS, disable active sampling and start large steps
            if (sequentialEmptySamples == EMPTY_STEPS_BEFORE_LARGE_STEPS)
                activeSampling = false;

            // Do the next step
            position += rayDirection * stepS;
        }
        else
        {
            // Sample the cheap version of the clouds
            CloudProperties cloudProperties;
            EvaluateCloudProperties(position, 1.0f, true, cloudProperties);

            // If the density is lower than our tolerance,
            if (cloudProperties.density < CLOUD_DENSITY_TRESHOLD)
            {
                stepMultiplier *= 1.1f;
                position += rayDirection * stepS * stepMultiplier;
            }
            else
            {
                // Somewhere between this step and the previous clouds started
                // We reset all the counters and enable active sampling
                position -= rayDirection * stepS * (stepMultiplier - 1.0f);
                activeSampling = true;
                stepMultiplier = 2.0f;
                sequentialEmptySamples = 0;
            }
        }
    }

    /*
    // Normalized the depth we computed
    if (volumetricRay.meanDepth == 0.0)
        volumetricRay.meanDepth = _MaxCloudDistance;
    else
        volumetricRay.meanDepth /= meanDepthDivider;
    */

    // return the final ray result
    return volumetricRay;
}

[numthreads(8, 8, 1)]
void RenderClouds(uint3 traceCoord : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(traceCoord.z);

    // If this is bigger than the trace size, we are done
    if (any(traceCoord.xy > uint2(_TraceScreenSize.xy)))
        return;

    // Compute the half res coordinate that matches this thread (as we virtually do the computation in half res space)
    uint2 halfResCoord = traceCoord.xy * 2 + HalfResIndexToCoordinateShift[_SubPixelIndex];

    // Build the ray we will use of the ray marching.
    CloudRay ray = BuildRay(halfResCoord);
    #ifdef CAMERA_CENTRIC_CLOUDS
    if (ray.direction.y < 0.0)
    {
        // If this is camera centric, we cannot see below the horizon
        _CloudsLightingTextureRW[COORD_TEXTURE2D_X(traceCoord.xy)] = float4(0.0, 0.0, 0.0, 1.0);
        return;
    }
    #endif

    // Compute the environment lighting that is going to be used for the cloud evaluation
    EnvironmentLighting envLighting = EvaluateEnvironmentLighting(ray);

    // We use the Heitz blue noise method for dithering to get the most visually pleasing noise.
    float offset = GetBNDSequenceSample(halfResCoord, _AccumulationFrameIndex, 0);

    // Evaluate the cloud transmittance
    VolumetricRayResult result = TraceVolumetricRay(ray.origin, ray.direction, ray.maxRayLength, envLighting, offset);

    // Apply a fast tonemap
    result.inScattering *= rcp(result.inScattering + 1.0);

    // output the result
    _CloudsLightingTextureRW[COORD_TEXTURE2D_X(traceCoord.xy)] = float4(result.inScattering, result.transmittance);
}

// Texture that has just been trace
TEXTURE2D_X(_CloudsLightingTexture);
// History result of the trace
TEXTURE2D_X(_HistoryVolumetricClouds0Texture);
// History result of the sample count
TEXTURE2D_X(_HistoryVolumetricClouds1Texture);

// Output of the reprojection
RW_TEXTURE2D_X(float, _CloudsSampleCountTextureRW);

// Our dispatch is a 8x8 tile. We access 3x3 values at half resolution around the center pixel which represents a total of 36 uniques values for the tile.
groupshared float gs_cacheR[36];
groupshared float gs_cacheG[36];
groupshared float gs_cacheB[36];
groupshared float gs_cacheA[36];

float4 GetLDSSample(uint index)
{
    float4 outVal;
    outVal.r = gs_cacheR[index];
    outVal.g = gs_cacheG[index];
    outVal.b = gs_cacheB[index];
    outVal.a = gs_cacheA[index];
    return outVal;
}

void FillLDS(uint groupIndex, uint2 groupOrigin)
{
    // Define which value we will be acessing with this worker thread
    int acessCoordX = groupIndex % 6;
    int acessCoordY = groupIndex / 6;

    // Everything we are accessing is in trace res (quarter rez).
    uint2 traceGroupOrigin = groupOrigin / 2;

    // The initial position of the access
    int2 originXY = traceGroupOrigin - int2(1, 1);

    // Compute the sample position
    int2 sampleCoord = int2(clamp(originXY.x + acessCoordX, 0, _TraceScreenSize.x - 1), clamp(originXY.y + acessCoordY, 0, _TraceScreenSize.y - 1));

    // Read the sample value
    float4 sampleVal = LOAD_TEXTURE2D_X(_CloudsLightingTexture, sampleCoord);

    // Store into the LDS
    gs_cacheR[groupIndex] = sampleVal.r;
    gs_cacheG[groupIndex] = sampleVal.g;
    gs_cacheB[groupIndex] = sampleVal.b;
    gs_cacheA[groupIndex] = sampleVal.a;
}

[numthreads(8, 8, 1)]
void ReprojectClouds(uint3 dispatchThreadId : SV_DispatchThreadID,
                    int groupIndex : SV_GroupIndex,
                    uint2 groupThreadId : SV_GroupThreadID,
                    uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);
    uint2 intermediateCoord = dispatchThreadId.xy;

    // Compute the set of coordinates we need
    uint2 fullResCoord = intermediateCoord * 2;
    uint2 traceCoord = intermediateCoord / 2;

    // Only 36 workers of the 64 do the pre-fetching
    if (groupIndex < 36)
    {
        // Load 1 value per thread
        FillLDS(groupIndex, groupId * 8);
    }

    // Make sure all values are loaded in LDS by now.
    GroupMemoryBarrierWithGroupSync();

    // Compute the motionVector of the clouds
    float2 motionVector = EvaluateCloudMotionVectors(fullResCoord);

    // Compute the history pixel coordinate to tap from
    float2 historyTapCoord = ((float2)intermediateCoord + 0.5f) - motionVector * _IntermediateScreenSize.xy;
    float2 clampedHistoryCoords = clamp(historyTapCoord, 0.0, _IntermediateScreenSize.xy - 1.0);

    // Read the volumetric cloud value from the previous frame
    float2 historySampleCoords = clampedHistoryCoords * _HistoryBufferSize.xy;
    float4 previousResult0 = SAMPLE_TEXTURE2D_X_LOD(_HistoryVolumetricClouds0Texture, s_linear_clamp_sampler, historySampleCoords, 0);
    previousResult0.xyz *= GetInversePreviousExposureMultiplier() * GetCurrentExposureMultiplier();
    float previousResult1 = SAMPLE_TEXTURE2D_X_LOD(_HistoryVolumetricClouds1Texture, s_linear_clamp_sampler, historySampleCoords, 0).x;

    // Read the region we will be using from the LDS
    float4 pixelRegion[9];
    for (int yIdx = -1; yIdx <= 1; ++yIdx)
    {
        for (int xIdx = -1; xIdx <= 1; ++xIdx)
        {
            // Compute the tap coordinate in the 6x6 grid
            int2 tapAddress = (int2)(groupThreadId / 2 + 1) + int2(xIdx, yIdx);
            uint ldsTapAddress = (uint)(tapAddress.x) % 6 + tapAddress.y * 6;
            pixelRegion[(xIdx + 1.0) + (yIdx + 1.0) * 3] = GetLDSSample(ldsTapAddress);
        }
    }

    // Is the history outside or inside the frame?
    float outsideFrameHistory = (historyTapCoord.x < 0.0 || historyTapCoord.x >= _IntermediateScreenSize.x || historyTapCoord.y < 0.0 || historyTapCoord.y >= _IntermediateScreenSize.y) ? 1.0 : 0.0;

    // In case we have some history, we do a more subtle blur, a gaussian one this time.
    // If we have no history we do a box blur.
    // The reason for this is to compensate for the low amount of samples that we have (0)
    float4 currentResult = pixelRegion[CENTER] * lerp(CENTER_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[PLUS_0] * lerp(PLUS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[PLUS_1] * lerp(PLUS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[PLUS_2] * lerp(PLUS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[PLUS_3] * lerp(PLUS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[CROSS_0] * lerp(CROSS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[CROSS_1] * lerp(CROSS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[CROSS_2] * lerp(CROSS_WEIGHT, 0.111111111, outsideFrameHistory);
    currentResult += pixelRegion[CROSS_3] * lerp(CROSS_WEIGHT, 0.111111111, outsideFrameHistory);

    // Compute the local index that tells us the index of this pixel, the strategy for reprojection is a bit different in both cases
    int localIndex = (intermediateCoord.x & 1) + (intermediateCoord.y & 1) * 2;
    if (localIndex == _SubPixelIndex)
    {
        float accumulationFactor = 0.0;
        float sampleCount = 1.0;
        // If the target coordinate is out of the screen, we cannot use the history
        if (!outsideFrameHistory)
        {
            // Define our accumation value
            accumulationFactor = previousResult1.x >= 16.0 ? 0.94117647058 : (previousResult1.x / (previousResult1.x + 1.0));
            accumulationFactor *= _TemporalAccumulationFactor;
            sampleCount = max(previousResult1 + 1.0, 16.0);
        }

        // Do the accumulation and saturate
        float4 finalResult = accumulationFactor * previousResult0 + (1.0 - accumulationFactor) * currentResult;
        finalResult.w = saturate(finalResult.w);

        // Accumulate the result with the previous frame
        previousResult0 = accumulationFactor * previousResult0 + (1.0 - accumulationFactor) * currentResult;
        previousResult1 = sampleCount;
    }
    else
    {
        // If the target coordinate is out of the screen, we cannot use the history
        if (outsideFrameHistory)
        {
            // Take the blurred region as history value
            previousResult0 = currentResult;
            // Force the sample count to one
            previousResult1 = 1.0;
        }

        // Reduce the history validity a bit
        previousResult1 *= _TemporalAccumulationFactor;
    }

    // Accumulate the result with the previous frame
    _CloudsLightingTextureRW[COORD_TEXTURE2D_X(intermediateCoord)] = previousResult0;
    _CloudsSampleCountTextureRW[COORD_TEXTURE2D_X(intermediateCoord)] = previousResult1;
}

// Constant buffer where all variables should land
CBUFFER_START(VolumetricCloudsUpscaleConstantBuffer)
    float2 _UpperScreenSize;
CBUFFER_END

// Full resolution depth texture
TEXTURE2D_X(_DepthTexture);

// Half resolution volumetric cloud texture
TEXTURE2D_X(_VolumetricCloudsTexture);

// Input output camera color buffer
RW_TEXTURE2D_X(float4, _CameraColorTextureRW);

[numthreads(8, 8, 1)]
void UpscaleAndCombineClouds(uint3 finalCoord : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(finalCoord.z);
    // If out of bounds, discard
    if (any(finalCoord.xy > uint2(_ScreenSize.xy)))
        return;

    // Grab the depth value of the pixel
    float depthValue = LOAD_TEXTURE2D_X(_DepthTexture, finalCoord.xy).x;

    // Read the color buffer
    float4 currentColor = _CameraColorTextureRW[COORD_TEXTURE2D_X(finalCoord.xy)];

    // Read the cloud data
    float4 currentClouds = SAMPLE_TEXTURE2D_X_LOD(_VolumetricCloudsTexture, s_linear_repeat_sampler, finalCoord * 0.5f * _HistoryBufferSize.xy, 0);

    // De-tonemap the inscattering value
    currentClouds.xyz *= rcp(1.0 - currentClouds.xyz);

    // If this is a background pixel, we want the cloud value, otherwise we do not.
    _CameraColorTextureRW[COORD_TEXTURE2D_X(finalCoord.xy)] = depthValue != UNITY_RAW_FAR_CLIP_VALUE ? currentColor : currentColor * currentClouds.a + float4(currentClouds.xyz, 0.0);
}
