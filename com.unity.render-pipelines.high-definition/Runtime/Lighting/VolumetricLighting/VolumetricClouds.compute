#pragma kernel RenderClouds
#pragma kernel CombineClouds

// HDRP generic includes
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/EntityLighting.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/ShaderVariablesPhysicallyBasedSky.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/VolumetricLighting/VolumetricCloudsManager.cs.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingSampling.hlsl"

// Tile size of this compute
#define VOLUMETRIC_CLOUDS_TILE_SIZE 8

#define ANVIL_BIAS 0.01
#define MOTION_DISTORTION 0.1

#pragma enable_d3d11_debug_symbols

// Input textures
TEXTURE2D_X(_CameraColorTexture);
TEXTURE2D_X(_DepthTexture);
Texture2D<float4> _CloudMapTexture;
Texture2D<float> _CloudLutTexture;
Texture3D<float4> _Worley128RGBA;
Texture3D<float3> _Worley32RGB;

// Output texture
RW_TEXTURE2D_X(float4, _VolumetricCloudsTextureRW);

// Structure that holds all the data required for the cloudray ray marching
struct CloudRay
{
    // Origin of the ray in absolute world space
    float3 origin;
    // Direction of the ray in world space
    float3 direction;
    // Maximal ray length before hitting the far plane or an occluder
    float maxRayLength;
};

CloudRay BuildRay(uint2 currentCoord)
{
    // Read the depth value
    float depthValue = LOAD_TEXTURE2D_X(_DepthTexture, currentCoord).r;

    // Compute the NDC position
    float2 positionNDC = (currentCoord + 0.5) * _ScreenSize.zw;

    // Build the ray
    CloudRay ray;
    // Is this a sky pixel?
    if (depthValue == UNITY_RAW_FAR_CLIP_VALUE)
    {
        // Compute a virtual position that we'll use for our direction generation
        float3 positionWS = ComputeWorldSpacePosition(positionNDC, 0.5f, UNITY_MATRIX_I_VP);
        ray.direction = normalize(positionWS);
        ray.maxRayLength = _ProjectionParams.z; // Far plane
    }
    else
    {
        // Compute the world space position of the occluder
        float3 positionWS = ComputeWorldSpacePosition(positionNDC, depthValue, UNITY_MATRIX_I_VP);
        // Compute the view vector of the camera
        ray.maxRayLength = length(positionWS);
        // Compute the ray direction
        ray.direction = positionWS / ray.maxRayLength;
    }

    // The ray is cast from the camera
    ray.origin = _WorldSpaceCameraPos;

    return ray;
}

// Density remapping function
float remap(float x, float low1, float high1, float low2, float high2)
{
    return low2 + (x - low1) / (high1 - low1) * (high2 - low2);
}

float2 IntersectAABB(float3 rayOrigin, float3 rayDir, float3 boxMin, float3 boxMax)
{
    float3 tMin = (boxMin - rayOrigin) / rayDir;
    float3 tMax = (boxMax - rayOrigin) / rayDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return float2(tNear, tFar);
}

bool PointInsideCloudVolumeAABB(float3 positionWS)
{
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float eps = 1e-4;
    return  (positionWS.x > minCorner.x-eps) && (positionWS.y > minCorner.y-eps) && (positionWS.z > minCorner.z-eps) && 
            (positionWS.x < maxCorner.x+eps) && (positionWS.y < maxCorner.y+eps) && (positionWS.z < maxCorner.z+eps);
}

bool GetCloudVolumeIntersection(float3 org, float3 dir, out float distToStart, out float totalDistance)
{
    float3 minCorner = float3(-_CloudDomeSize, _LowestCloudAltitude, -_CloudDomeSize);
    float3 maxCorner = float3(_CloudDomeSize, _HighestCloudAltitude, _CloudDomeSize);
    float2 intersections = IntersectAABB(org, dir, minCorner, maxCorner);
    
    if(PointInsideCloudVolumeAABB(org))
        intersections.x = 1e-4;
    
    distToStart = intersections.x;
    totalDistance = intersections.y - intersections.x;
    return intersections.x > 0.0 && (intersections.x < intersections.y);
}

// Structure that holds all the data used to define the cloud density of a point in space
struct CloudCoverageData
{
    // From a top down view, in what proportions this pixel has clouds
    float coverage;
    // Value that allows us to request the cloudtype using the density
    float cloudType;
};

CloudCoverageData GetCloudCoverageData(float3 positionWS)
{
    // Convert the position into dome space
    float2 normalizedPosition = saturate(positionWS.xz / _CloudDomeSize * 0.5 + 0.5);
    // Read the data from the texture
    float4 cloudMapData =  SAMPLE_TEXTURE2D_LOD(_CloudMapTexture, s_linear_clamp_sampler, float2(normalizedPosition.x, normalizedPosition.y), 0.0);
    CloudCoverageData data;
    // TODO: Fix this
    data.coverage = cloudMapData.x * 0.4;
    data.cloudType = cloudMapData.w;
    return data;
}

// Structure that holds all the lighting data required to light the cloud particles
struct EnvironmentLighting
{
    // Light direction (point to sun)
    float3 sunDirection;
    // Light intensity/color of the sun, this already takes into account the atmospheric scattering
    float3 sunColor;
    // Ambient term from the ambient probe
    float3 ambientTerm;
};

EnvironmentLighting EvaluateEnvironmentLighting(CloudRay ray)
{
    // Sun parameters
    EnvironmentLighting environmentLight;
    environmentLight.sunDirection = _SunDirection;
    environmentLight.sunColor = _SunLightColor * (_ExposureSunColor ? GetCurrentExposureMultiplier() : 1.0);
    environmentLight.ambientTerm = SampleSH9(_AmbientProbeCoeffs, ray.direction) * GetCurrentExposureMultiplier();

    // TODO: move this into a shared function
    {
        // TODO: should probably unify height attenuation somehow...
        // TODO: Not sure it's possible to precompute cam rel pos since variables
        // in the two constant buffers may be set at a different frequency?
        float3 X = ray.origin;
        float3 C = _PlanetCenterPosition.xyz;

        float r        = distance(X, C);
        float cosHoriz = ComputeCosineOfHorizonAngle(r);
        float cosTheta = dot(X - C, environmentLight.sunDirection) * rcp(r); // Normalize

        if (cosTheta >= cosHoriz) // Above horizon
        {
            float3 oDepth = ComputeAtmosphericOpticalDepth(r, cosTheta, true);
            // Cannot do this once for both the sky and the fog because the sky may be desaturated. :-(
            float3 transm  = TransmittanceFromOpticalDepth(oDepth);
            float3 opacity = 1 - transm;
            environmentLight.sunColor.rgb *= 1 - (Desaturate(opacity, _AlphaSaturation) * _AlphaMultiplier);
        }
        else
        {
            // return 0; // Kill the light. This generates a warning, so can't early out. :-(
           environmentLight.sunColor = 0;
        }
    }
    return environmentLight;
}

struct CloudProperties
{
	// Normalized float that tells is the "amount" of clouds that is at a given location
	float density;
	// Normalized value that tells us the height within the cloud volume (vertically)
	float height;
};

void EvaluateCloudProperties(float3 positionWS, bool cheapVersion, out CloudProperties properties)
{
    // Initliaze all the values to 0 in case
    ZERO_INITIALIZE(CloudProperties, properties);

    // If the next sampling point is not inside the AABB, the density is already set to 0, we can skip right away.
    if (!PointInsideCloudVolumeAABB(positionWS))
        return;

    // Evaluate the cloud coverage data for this position
    CloudCoverageData cloudCoverageData = GetCloudCoverageData(positionWS);

    // Evaluate the normalized height of the position within the cloud volume
    properties.height = saturate((positionWS.y - _LowestCloudAltitude) / (_HighestCloudAltitude - _LowestCloudAltitude));

    // If this region of space has no cloud coverage, exit right away
    if (cloudCoverageData.coverage == 0.0)
    	return;

    // Evaluate the coordinates at which the noise will be sampled
    float3 noiseSamplingCoordinates = positionWS.xzy * 0.0001 + _WindDirection * _Time * 0.01;    
    noiseSamplingCoordinates += properties.height * _WindDirection * MOTION_DISTORTION;

    // Read the low frequency Perlin-Worley and Worley noises
    float4 lowFrequencyNoises = SAMPLE_TEXTURE3D_LOD(_Worley128RGBA, s_trilinear_repeat_sampler, noiseSamplingCoordinates, 0.0);
    float lowFreqFBm = ( lowFrequencyNoises.y * 0.625 ) + ( lowFrequencyNoises.z * 0.25 ) + ( lowFrequencyNoises.w * 0.125);

    // Remap the perlin-worley noise with the worley fbm
    float base_cloud = remap(lowFrequencyNoises.x, -(1.0 - lowFreqFBm), 1.0, 0.0, 1.0);

    // Evaluate the density by the height-base density gradient of the cloud that we are handeling
    float densityHeightGradient = SAMPLE_TEXTURE2D_LOD(_CloudLutTexture, s_linear_clamp_sampler, float2(cloudCoverageData.cloudType, properties.height), 0.0).x;
	
    // Apply the height function to the base cloud shape
    base_cloud *= densityHeightGradient;

    // apply anvil deformations
    cloudCoverageData.coverage = pow(cloudCoverageData.coverage, remap(properties.height, 0.7, 0.8, 1.0, lerp(1.0, 0.5, ANVIL_BIAS)));

	// Rmap the base cloud with the coverage
    properties.density = remap(base_cloud, cloudCoverageData.coverage, 1.0, 0.0, 1.0);

    // Multiply the result by the cloud coverage so that the smaller clouds are lighter and more esthetically pleasing
    properties.density *= cloudCoverageData.coverage;

    properties.density = saturate(properties.density);

    if (!cheapVersion)
    {
            // Sample high frequency noises
        float3 high_frequency_noises = SAMPLE_TEXTURE3D_LOD(_Worley32RGB, s_trilinear_repeat_sampler, noiseSamplingCoordinates * 0.1, 0.0).xyz;

        // Build high frequency worley noise FBM
        float high_freq_FBM = (high_frequency_noises.r * 0.625) + ( high_frequency_noises.g * 0.25 ) + ( high_frequency_noises.b * 0.125 );

        // Trans it ion from wispy shapes to billowy shapes over height 
        float high_freq_noise_modifier = lerp(high_freq_FBM, 1.0 - high_freq_FBM , saturate ( properties.height * 10.0));

        // Erode the base cloud shape with the distorded high frequency worley noises
        float final_cloud = remap(properties.density, high_freq_noise_modifier * 0.2 , 1.0 , 0.0 , 1.0);

        // Output the final density value
        properties.density = saturate(final_cloud);
    }
}

float HenyeyGreenstein(float cosAngle, float g)
{
    // There is a mistake in the GPU Gem7 Paper, the result should be divided by 1/(4.PI)
    float g2 = g * g;
    return (1.0 - g2) / (pow(1.0 + g2 - 2.0 * g * cosAngle, 1.5) * (4.0 * PI));
}

//Get the amount of light that reaches a sample point.
float3 EvaluateLightRay(float3 positionWS, float phaseFunction, float mu, float3 sunDirection, float normalizedHeight, float density, float stepSize, float offset)
{
    // Compute the Ray to the limits of the cloud volume in the direction of the light
    float lightRayDistance = 0.0f;
    float distToStart = 0.0;
    GetCloudVolumeIntersection(positionWS, sunDirection, distToStart, lightRayDistance);
    
    // Compute the step of the light integration
    float stepL = lightRayDistance/(float)_NumLightSteps;

    // Initialize the accumulation value for the light ray density
    float lightRayDensity = 0.0;
    
    //Collect total density along light ray.
    for(int j = 0; j < _NumLightSteps; j++)
    {
        // Evaluate the current sample point
        float3 currentSamplePoint = positionWS + sunDirection * (float)j * stepL;

        // Get the cloud properties at the sample point
        CloudProperties cloudProperties;
        EvaluateCloudProperties(currentSamplePoint, false, cloudProperties);

        // Reduce density of clouds when looking towards the sun for more luminous clouds.
        lightRayDensity += cloudProperties.density;
    }

    const float3 sigmaE = max(_ScatteringTint, float3(1e-6, 1e-6,1e-6));
    float3 beersLaw = max(exp(-stepL * lightRayDensity * sigmaE), exp(-stepL * lightRayDensity * sigmaE * 0.2) * 0.75);
    
    float depth_probability = lerp( 0.05 + pow( density, remap( normalizedHeight, 0.3, 0.85, 0.5, 2.0 )), 1.0, saturate( density / stepSize));
    float vertical_probability = pow( remap( normalizedHeight, 0.07, 0.14, 0.1, 1.0 ), 0.8 );
    float in_scatter_probability = depth_probability * vertical_probability;

    // TODO: Phase function behaving in a weird way
    return 2.0 * beersLaw * in_scatter_probability /* phaseFunction */;
}

float3 TraceVolumetricRay(float3 rayOrigin, float3 rayDirection, float maxRayLength,
                            EnvironmentLighting environmentLighting, float offset,
                            out float3 transmisttance)
{    
    // Initially everything is transmitted
    transmisttance = 1.0;

    // Determine if ray intersects bounding volume, if the ray does not intersect the cloud volume AABB, skip right away
    float startDistance = 0.0;
    float totalDistance = 0.0;
    if (!GetCloudVolumeIntersection(rayOrigin, rayDirection, startDistance, totalDistance))
        return 0.0;

    // Clamp the travel distance to whatever is closer
    // - Sky Occluder
    // - Volume end
    // - Far plane
    totalDistance = min(totalDistance, maxRayLength - startDistance);

    // Evaluate our integration step
    float stepS = totalDistance / (float)_NumPrimarySteps; 
    
    // Offset the starting point using our dithering pattern.
    startDistance += stepS * offset;
    
    // Evaluate cos of the theta angle between the view and light vectors
    const float3 viewVector = -rayDirection;
    float cosAngle = dot(viewVector, environmentLighting.sunDirection);

    // Evaluate the phase function for our ray direction
    const float phaseFunction = max(HenyeyGreenstein(_Eccentricity, cosAngle), _SilverIntensity * HenyeyGreenstein(1.0 - _SilverSpread, cosAngle));

    // Initialize the integration values
    float3 colour = 0.0;
    float currentDistance = startDistance;
    float3 position = rayOrigin + startDistance * rayDirection;

    // Do the ray march for every step that we can.
    for(int i = 0; i < _NumPrimarySteps; i++)
    {
        // Evaluate the density and height at the current ray marching point
        CloudProperties cloudProperties;
        EvaluateCloudProperties(position, false, cloudProperties);

        // If the density is null, we can skip as there will be no contribution
        if (cloudProperties.density > 0.0)
        {
            float3 luminance = environmentLighting.ambientTerm + environmentLighting.sunColor * EvaluateLightRay(position, phaseFunction, cosAngle, environmentLighting.sunDirection, cloudProperties.height, cloudProperties.density, stepS, offset);
            // Evaluate the sampled transmittance
	        const float3 sigmaE = max(_ScatteringTint, float3(1e-6, 1e-6,1e-6));
	        float3 sampleSigmaE = sigmaE * cloudProperties.density;
            float3 sampleTransmittance = exp(-sampleSigmaE * stepS);

            // Beer-Lambert.
            float3 sampleSigmaS = _ScatteringTint * cloudProperties.density;

        	// Scale light contribution by density of the cloud.
            luminance *= sampleSigmaS;

            // Better energy conserving integration
            // "From Physically based sky, atmosphere and cloud rendering in Frostbite" 5.6 by Sebastian Hillaire.
            colour += transmisttance * (luminance - luminance * sampleTransmittance) / sampleSigmaE; 

            //Attenuate the amount of light that reaches the camera.
            transmisttance *= sampleTransmittance;  

            // If ray combined transmittance is close to 0, nothing beyond this sample point is visible, so break early.
            if(length(transmisttance) <= 0.001)
            {
                transmisttance = (0.0);
                break;
            }
        }   

        currentDistance += stepS;

        // Step along ray.
        position = rayOrigin + rayDirection * currentDistance;
    }

    return colour;
}

[numthreads(VOLUMETRIC_CLOUDS_TILE_SIZE, VOLUMETRIC_CLOUDS_TILE_SIZE, 1)]
void RenderClouds(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Compute the pixel position to process
    uint2 currentCoord = groupId * VOLUMETRIC_CLOUDS_TILE_SIZE + groupThreadId;

    // Grab the color value of the color buffer
    float3 colorValue = LOAD_TEXTURE2D_X(_CameraColorTexture, currentCoord).xyz;

    // Build the ray we will use of the ray marching.
    CloudRay ray = BuildRay(currentCoord);

    // Compute the environment lighting that is going to be used for the cloud evaluation
    EnvironmentLighting environmentLight = EvaluateEnvironmentLighting(ray);
    
    // We use the Heitz blue noise method for dithering to get the most visually pleasing noise.
    float offset = GetBNDSequenceSample(currentCoord, _AccumulationFrameIndex, 0);
    
    // Evaluate the cloud transmittance
    float3 totalTransmittance = float3(1.0, 1.0, 1.0);
    float3 finalColor = TraceVolumetricRay(ray.origin, ray.direction, ray.maxRayLength, environmentLight, offset, totalTransmittance); 

    // Combine the result with the background color
    finalColor += colorValue * totalTransmittance;

    // output the result
    _VolumetricCloudsTextureRW[COORD_TEXTURE2D_X(currentCoord)] = float4(finalColor, 1.0);
}

TEXTURE2D_X(_VolumetricCloudsTexture);
RW_TEXTURE2D_X(float4, _CameraColorTextureRW);

[numthreads(VOLUMETRIC_CLOUDS_TILE_SIZE, VOLUMETRIC_CLOUDS_TILE_SIZE, 1)]
void CombineClouds(uint3 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
    UNITY_XR_ASSIGN_VIEW_INDEX(dispatchThreadId.z);

    // Compute the pixel position to process
    uint2 currentCoord = groupId * VOLUMETRIC_CLOUDS_TILE_SIZE + groupThreadId;
    _CameraColorTextureRW[COORD_TEXTURE2D_X(currentCoord)] = LOAD_TEXTURE2D_X(_VolumetricCloudsTexture, currentCoord);
}